### 네이밍
변수명/함수명/클래스명의 이름을 결정할 때는 항상 같은 원리가 적용된다. 이름은 **일종의 설명문**으로 간주해야 한다. 적절한 이름을 붙일 수 있다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다. 반대로 어울리지 않는 이름을 붙여졌다는 것은 해당 요소가 달성해야 할 역할에 대해 프로그래머 자신이 충분히 이해하지 못했다는 뜻이다.

#### 효과적인 네이밍 작성
네이밍을 통해 프로그래머끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드상의 대화는 성립하지 않는다. **효과적인 이름**을 작성하기 위해서는 이러한 과정이 필요하다.

- 이름은 효과와 목적을 설명하도록 한다.
- 이름은 발음 가능한 것으로 한다.
- 이름은 검색 가능하도록 한다.

#### 네이밍을 잘했는 지 확인하려면?
명명에는 **이름 가역성**이라는 개념이 있다. 이는 **이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 있어야 한다**는 명명 방침이다. 이 방침을 충족하려면 **루프백 확인**을 수행해야 한다.

**루프백 확인**은 내용의 설명문으로 부터 이름을 떠올렸다면 반대로 이름을 추측할 수 있는 설명문을 생각해보는 것이다. **설명 -> 이름 -> 설명**의 순으로 한 바퀴 돌아서 원래로 돌아왔을 때 설명이 일치하면 좋은 이름이고, 일치하지 않으면 주의가 필요하다.

```js
const sum = (a, b) => a + b
```
```
(a, b) => a + b -> sum -> (a, b) => a + b
```

#### 이름에 정보를 담아내는 방법
1. 보편적인 단어를 피하고 구체적인 단어를 선택한다.

**어디에서 가져오는 지**, **무엇을 수행하는 지**, **무엇을 반환하는 지**에 따라 구체적인 단어를 선택할 수 있다. 예를 들어 페이지를 요청할 때는 `getPage()`보다는 `fetchPage()`, 사이즈를 가져올 때는 `size`보다는 `height`, `nodesLength`, `memoryBytes`와 같이 구체적인게 정확한 의도를 전달할 수 있다.

2. 시간의 양이나 바이트의 수 같이 측정치를 포함한다면, **단위**를 포함시킨다.
```js
// Not Cool
const start = new Date().getTime()
...
const end = new Date().getTime() - start
console.log(`Load time was: ${end} seconds`) // Wrong!!

// Cool
const startMs = new Date().getTime()
...
const endMs = new Date().getTime() - startMs
console.log(`Load time was: ${endMs / 1000} seconds`)
```

3. 위험한 요소 표현
나중에 잘못 이해했을 때 심각한 버그를 만들 가능성 있는 것들을 표현하는 게 좋다.
- 패스워드가 암호화 안되있다면 : `password` => `plainTextPassword`
- URL Encoded 데이터라면 : `data` => `dataURLEnc`
- 이스케이프 처리가 되어야 한다면 : `comment` => `unescapedComment`

#### 이름은 얼마나 길어야 할까?
**좁은 범위**에서는 짧은 이름이 괜찮다. 좁은 범위에서만 사용되는 변수의 이름에 많은 정보를 담을 필요가 없기 때문이다. 좁은 범위에서는 변수의 타입, 초기값 등 모든 정보가 쉽게 한눈에 보이므로 짧은 이름을 사용해도 좋다.

범위에 따라 불필요한 단어를 제거할 수 있다. 정보의 손실하지 않으면서 이름에 포함된 단어를 제거할 수 있다. `convertToString()` => `toString()`

**약어와 축약형**을 사용하는 것은 특정 프로젝트에 국한된 의미를 가지기 때문에 좋은 생각이 아니다. 새로 합류한 사람에게는 비밀스럽고 위협적인 모습이다. **팀에 새로합류한 사람이 이름을 의미하는 바를 이해할 수 있을 까**를 기준으로 생각하는 게 좋다.