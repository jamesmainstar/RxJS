### 네이밍
변수명/함수명/클래스명의 이름을 결정할 때는 항상 같은 원리가 적용된다. 이름은 일종의 설명문으로 간주해야 한다. 적절한 이름을 붙일 수 있다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다. 반대로 어울리지 않는 이름을 붙여졌다는 것은 해당 요소가 달성해야 할 역할에 대해 프로그래머 자신이 충분히 이해하지 못했다는 뜻이다.

#### 효과적인 네이밍 작성
네이밍을 통해 프로그래머끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드상의 대화는 성립하지 않는다. **효과적인 이름**을 작성하기 위해서는 이러한 과정이 필요하다.

- 이름은 효과와 목적을 설명하도록 한다.
- 이름은 발음 가능한 것으로 한다.
- 이름은 검색 가능하도록 한다.

#### 네이밍을 잘했는 지 확인하려면?
명명에는 **이름 가역성**이라는 개념이 있다. 이는 **이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 있어야 한다**는 명명 방침이다. 이 방침을 충족하려면 **루프백 확인**을 수행해야 한다.

내용의 설명문으로부터 이름을 떠올렸다면 반대로 이름을 추측할 수 있는 설명문을 생각해보는 것이다. **설명 -> 이름 -> 설명**의 순으로 한 바퀴 돌아서 원래로 돌아왔을 때 설명이 일치하면 좋은 이름이고, 일치하지 않으면 주의가 필요하다.

```js
const sum = (a, b) => a + b
```
```
(a, b) => a + b -> sum -> (a, b) => a + b
```

#### 1_1. 보편적인 단어를 피하고 구체적인 단어를 선택
- 구체적인 단어를 통해 정확한 의도한 정보를 전달해야 함
- 어디에서 가져오는 지
  - `getPage()` => `fetchPage(), downloadPage()`
- 무엇을 수행하는 지
  - `stop()` => `kill(), resume(), pause()`
- 무엇을 반환하는 지
  - `size()` => `height(), nodesLength(), memoryBytes()`


#### 1_2. 단위를 포함하는 것들
- 시간의 양이나 바이트의 수와 같이 측정치를 포함하면
- 단위를 포함하는 것이 좋습니다.
```js
// Not Cool
const start = new Date().getTime()
...
const end = new Date().getTime() - start
console.log(`Load time was: ${end} seconds`) // Wrong!!

// Cool
const startMs = new Date().getTime()
...
const endMs = new Date().getTime() - startMs
console.log(`Load time was: ${endMs / 1000} seconds`)
```

#### 1_3. 다른 중요한 속성 포함하기
- 위험한 요소
- 나중에 잘못 이해했을 때 심각한 버그를 만들 가능성 있는 것들

- 패스워드가 암호화 안되있다면 : `password` => `plainTextPassword`
- URL Encoded 데이터라면 : `data` => `dataURLEnc`
- 이스케이프 처리가 되어야 한다면 : `comment` => `unescapedComment`