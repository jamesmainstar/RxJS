#### 퍼셉트론 알고리즘
- 프랑크 로젠 블라트 | 1957
- 신경망의 기원
- 다수의 신호를 입력으로 받아, 하나의 신호를 출력한다.
- 출력은 1, 0이 있다.
- 1은 `신호가 흐른다`라는 의미
- 0은 `신호가 흐르지 않는다`다는 의미

뉴런에서 보내온 신호의 총합이 정해진 한계를 넘어설때 1을 출력한다. 한계값을 임계값이라 하며 쎄타로 나타낸다.

```js
const and = (x1, x2) => {
  const [w1, w2, theta] = [0.5, 0.5, 0.7]
  const result = w1 * x1 + w2 * x2;
  return result > theta ? 1 : 0;
}
console.log(
  and(0, 0),
  and(1, 0),
  and(0, 1),
  and(1, 1)
);
```

#### 가중치와 편향 도입
쎄타를 -b 로 치환하면 퍼셉트론의 동작이 아래와 같이 됩니다.

```js
const and = (x1, x2) => {
  const [w1, w2, b] = [0.5, 0.5, -0.7];
  return w1 * x1 + w2 * x2 + b > 0 ? 1 : 0;
}
console.log(
  and(0, 0),
  and(1, 0),
  and(0, 1),
  and(1, 1)
);
```

- w1, w2 : 입력 신호가 결과에 주는 영향력을 조절하는 매개변수
- b : 편향은 뉴런이 얼마나 쉽게 활성화 하느냐를 조정하는 매개변수, 편향의 값은 뉴런이 얼마나 쉽게 활성화되는지를 결정한다.

#### NAND
```js
const nand = (x1, x2) => {
  const [w1, w2, b] = [-0.5, -0.5, 0.7];
  return w1 * x1 + w2 * x2 + b > 0 ? 1 : 0;
}
console.log(
  nand(0, 0),
  nand(1, 0),
  nand(0, 1),
  nand(1, 1)
);
```
#### OR
```js
const or = (x1, x2) => {
  const [w1, w2, b] = [0.5, 0.5, -0.2];
  return w1 * x1 + w2 * x2 + b > 0 ? 1 : 0;
}
console.log(
  or(0, 0),
  or(1, 0),
  or(0, 1),
  or(1, 1)
);
```

#### 퍼셉트론의 한계
XOR 게이트를 구현할 수 없습니다. 그래프로 표현했을 때 정상적으로 구역을 나눌 수 없습니다.
퍼셉트론은 직선 하나로 나눈 영역만 표현할 수 있다는 한계가 있습니다.

#### 다층 퍼셉트론
퍼셉트론의 아룸다움은 `층을 쌓아` 다층 퍼셉트론을 만들 수 있다는 데 있습니다.

퍼셉트론을 조합하면 XOR 게이트를 구현할 수 있습니다. x1과 x2가 입력 신호, y가 출력신호입니다. x1과 x2는 NAND와 OR게이트의 입력이 되고, NAND와 OR의 출력이 AND 게이트의 입력으로 이어집니다.

```js
const xor = (x1, x2) => {
  const s1 = nand(x1, x2);
  const s2 = or(x1, x2);
  return and(s1, s2);
};
console.log(
  xor(0, 0),
  xor(1, 0),
  xor(0, 1),
  xor(1, 1)
);
```

XOR은 2층 퍼셉트론입니다. 이처럼 층이 여러 개인 퍼셉트론을 다층 퍼셉트론이라 합니다.

#### NAND에서 컴퓨터까지
컴퓨터 내부에서 이뤄지는 처리가 매우 복잡할 거 같지만, 사실은 NAND 게이트의 조합만으로 컴퓨터가 수행하는 일을 재현할 수 있습니다. `The Elements of Computing Systems: Building a Modern Computer from First Principles | (The MIT Press, 2005)` 책은 컴퓨터를 깊이 이해하고자 **NAND에서 테트리스까지**라는 구호 아래, 실제로 NAND라는 단순한 소자만으로 컴퓨터와 같은 복잡한 시스템이 만들어진다는 것을 실감할 수 있을 겁니다.