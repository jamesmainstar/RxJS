> 기술 스택은 Angular, TypeScript 사용중이다.

### 목차
- 날짜 헬퍼를 만들게 된 이유
- 프로젝트에 적합한 방식 선정하기
- 인터페이스 설계하기
- 개발하기
- 적용하기
- 적용 후

### 날짜 헬퍼를 만들게 된 이유
우선 자바스크립트에서 날짜를 다루는 방법은 **Date**를 사용한다. **Date**를 사용해서 달력이나 지난시간, D-Day를 계산하게 된다. 날짜 헬퍼는 이런 연산작업을 한 곳에서 정의하기 위한 공통 코드를 의미한다.

이제 왜 날짜 헬퍼를 만들게 되었는 지 그리고 필요한지 알아보겠다.

날짜를 다루는 방법은 프로젝트 코드에서 너무 다양했다. 숫자타입의 타임스탬프, YYYY-MM-DD 형태의 문자타입, Moment 라이브러리, Date 등 다양한 형태로 존재했다. 하지만 다양한 타입은 계산하는 로직에는 필요하지 않다. YYYY-MM-DD의 형태는 API 통신이나 탬플리에 필요한 타입이다. 타임스탬프는 비교 연산을 위해 사용되는 데, 자바스크립트는 문자도 비교연산을 사용가능하다. 그렇기 때문에 타임스탬프도 불필요하다.

##### 날짜를 다루는 방법이 많다...
```ts
const timestamp: number = Date.now()
const dateFormat: string = moment().format('YYYY-MM-DD')
const current: Moment = moment()
const date: Date = new Date()
```

날짜를 의미하는 코드가 불규칙인 타입을 사용하기 때문에 단일 타입을 사용하는 강제성이 필요하다. 생성과 연산작업을 한곳에서 관리하기 위해 날짜 헬퍼를 만들었다.

### 프로젝트에 적합한 방식 선정하기
헬퍼를 만들게 되서 어떤 형태로 개발을 할지 고민을 했다. 멀티 페러다임으로 개발중이라 함수형으로 할지 아니면 객체지향으로 할지 고민을 했다. 그래서 두가지 방향으로 자주사용되는 인터페이스를 10가지 정도 만들어 봤다.

그런데 가장 중요한 사항을 잊고 있었다. 실제로 사용한 프로젝트 구성원의 의견을 듣는 게 좋겠다는 생각이 들었다. 그래서 회의를 통해서 선호하는 타입을 선정했고, 내가 생각하는 방향과 다르게 타입이 결정되었다. 타입은 문자로 결정되었고, Moment와 Date는 직접 사용하는 것은 제재하기로 했다.

추측컨데 내가 생각했던 방향으로만 진행됬으면 오히려 적응하는 데 시간이 좀 걸렸지 않을까 싶다.

##### 함수형이라면 Immutable 한 Date로
```js
const addDate = date => count => {
  const clonedDate = new Date(date)
  clonedDate.setDate(clonedDate.getDate() + count)
  return clonedDate
}

const today = new Date(2019, 0, 1)
const addFromToday = addDate(today)
const tomorrow = addFromToday(1)
const nextWeek = addFromToday(7)

console.log(today.getDate()) // 1
console.log(tomorrow.getDate()) // 2
console.log(nextWeek.getDate()) // 8
```

##### 객체지향이면 Date 상속해서
```js
class CustomDate extends Date { 
  addDate (count) {
    this.setDate(this.getDate() + count)
  }
  static create (...args) {
    return new CustomDate(...args)
  }
}

const customDate = CustomDate.create(2019, 0, 1)
console.log(customDate.getDate()) // 1
customDate.addDate(10)
console.log(customDate.getDate()) // 11
```

##### 하지만 현재는 이렇게
> @Injectable()은 Angular의 Service 정의시 사용되는 데코레이터이다.

```ts
@Injectable()
export class MomentHelper {
  addDate (date: string, count: number): string {
    return moment(date)
      .add(count, 'days')
      .format(format)
  }
}
```

### 인터페이스 설계하기
#### 먼저 프로젝트에서 사용하는 기능을 식별한다.
- 다음 날짜, 이전 날짜 이동
- 년월일 비교
- 윤달 여부
- 마지막 달 가져오기
- 어제 날짜
- 날짜를 특정 포맷으로 변환하기
- 날짜범위 가져오기

이러한 기능들이 식별된다. 

#### 그럼 이 기능을 토대로 인터페이스를 만든다.
```ts
class BeeDate extends Date {
  addDate(count: number): BeeDate {}
  subtractDate(count: number): BeeDate {}
  format(mapper: FormatMapper): string {}
  range(afterDate: BeeDate): BeeDate[] {}
  isSameDate(date: BeeDate): boolean {}
  isSameMonth(date: BeeDate): boolean {}
  isSameYear(date: BeeDate): boolean {}
  isLeapYear(): boolean {}
  getLastDay(): number {}
  getYesterday(): BeeDate {}
  clone(): BeeDate {}
  
  static create(value: number | string | BeeDate): BeeDate {}
  static createFromDate(
    year?: number,
    month?: number,
    date?: number,
    hours?: number,
    minutes?: number,
    seconds?: number,
    ms?: number
  ): BeeDate {}
}
```

#### 실제 사용되는 곳에서 인터페이스만 변경해본다.
인터페이스를 설계해도 실제로 사용되는 곳에서 사용해보는 것이 좋다. 실제로 사용했을 때 원하는 방향으로 설계가 됬는 지 그리고 깔끔하게 설계가 되었는 지 알 수 있다. 그리고 인터페이스만 변경해보면서 중복적인 요소가 보이면서 필요한 기능을 또 식별할 수 있다.

### 개발하기
#### 테스트 코드를 작성하고 인터페이스 개발한다.
테스트 코드를 통해 해당 메소드들이 어떻게 동작해야 하는 지 스펙을 작성한다. 그리고 각 메소드들의 기능을 추가한다.

#### 개발 완료 후 리펙토링
모든 코드가 개발되면 리펙토링을 한다. 테스트 코드를 통해 안전한 동작을 보장하기 때문에 리펙토링을 해도 안전성을 보장할 수 있다.

### 적용하기

### 적용 후
#### 성능
- Webpack 번들링 결과
- 속도

#### 장점
- 단일 인터페이스
- 외부 의존성 제거
- 타입 단일화