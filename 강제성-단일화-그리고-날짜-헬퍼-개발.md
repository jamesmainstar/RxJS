> 기술 스택은 Angular, TypeScript 사용중이다.

### 목차
- 날짜 헬퍼를 만들게 된 이유
- 프로젝트에 적합한 방식 선정하기
- 인터페이스 설계하기
- 개발하기
- 적용하기

### 날짜 헬퍼를 만들게 된 이유
우선 자바스크립트에서 날짜를 다루는 방법은 **Date**를 사용한다. **Date**를 사용해서 달력이나 지난시간, D-Day를 계산하게 된다. 날짜 헬퍼는 이런 연산작업을 한 곳에서 정의하기 위한 공통 코드를 의미한다.

이제 왜 날짜 헬퍼를 만들게 되었는 지 그리고 필요한지 알아보겠다.

날짜를 다루는 방법은 프로젝트 코드에서 너무 다양했다. 숫자타입의 타임스탬프, YYYY-MM-DD 형태의 문자타입, Moment 라이브러리, Date 등 다양한 형태로 존재했다. 하지만 다양한 타입은 계산하는 로직에는 필요하지 않다. YYYY-MM-DD의 형태는 API 통신이나 탬플리에 필요한 타입이다. 타임스탬프는 비교 연산을 위해 사용되는 데, 자바스크립트는 문자도 비교연산을 사용가능하다. 그렇기 때문에 타임스탬프도 불필요하다.

##### 날짜를 다루는 방법이 많다...
```ts
const timestamp: number = Date.now()
const dateFormat: string = moment().format('YYYY-MM-DD')
const current: Moment = moment()
const date: Date = new Date()
```

날짜를 의미하는 코드가 불규칙인 타입을 사용하기 때문에 단일 타입을 사용하는 강제성이 필요하다. 생성과 연산작업을 한곳에서 관리하기 위해 날짜 헬퍼를 만들었다.

### 프로젝트에 적합한 방식 선정하기
헬퍼를 만들게 되서 어떤 형태로 개발을 할지 고민을 했다. 멀티 페러다임으로 개발중이라 함수형으로 할지 아니면 객체지향으로 할지 고민을 했다. 그래서 두가지 방향으로 자주사용되는 인터페이스를 10가지 정도 만들어 봤다.

그런데 가장 중요한 사항을 잊고 있었다. 실제로 사용한 프로젝트 구성원의 의견을 듣는 게 좋겠다는 생각이 들었다. 그래서 회의를 통해서 선호하는 타입을 선정했고, 내가 생각하는 방향과 다르게 타입이 결정되었다. 타입은 문자로 결정되었고, Moment와 Date는 직접 사용하는 것은 제재하기로 했다.

추측컨데 내가 생각했던 방향으로만 진행됬으면 오히려 적응하는 데 시간이 좀 걸렸지 않을까 싶다.

##### 함수형이라면 Immutable 한 Date로
```js
const addDate = date => count => {
  const clonedDate = new Date(date)
  clonedDate.setDate(clonedDate.getDate() + count)
  return clonedDate
}

const today = new Date(2019, 0, 1)
const addFromToday = addDate(today)
const tomorrow = addFromToday(1)
const nextWeek = addFromToday(7)

console.log(today.getDate()) // 1
console.log(tomorrow.getDate()) // 2
console.log(nextWeek.getDate()) // 8
```

##### 객체지향이면 Date 상속해서
```js
class CustomDate extends Date { 
  addDate (count) {
    this.setDate(this.getDate() + count)
  }
  static create (...args) {
    return new CustomDate(...args)
  }
}

const customDate = CustomDate.create(2019, 0, 1)
console.log(customDate.getDate()) // 1
customDate.addDate(10)
console.log(customDate.getDate()) // 11
```

##### 하지만 현재는 이렇게
> @Injectable()은 Angular의 Service 정의시 사용되는 데코레이터이다.

```ts
@Injectable()
export class MomentHelper {
  addDate (date: string, count: number): string {
    return moment(date)
      .add(count, 'days')
      .format('YYYY-MM-DD')
  }
}
```

### 인터페이스 설계하기
먼저 프로젝트에서 사용하는 기능을 식별한다. 프로젝트 전체 코드 검색에서 **new Date**, **Date.now**, **moment**를 검색하면 된다. 추가적으로 기존에 사용중인 유틸리티인 **DateUtils**도 검색했다.

자주 사용되는 기능 추렸을 때 이런 기능들이 식별됬다.
```
- 다음 날짜, 이전 날짜 이동
- 년월일 비교
- 윤달 여부
- 마지막 달 가져오기
- 어제 날짜
- 날짜를 특정 포맷으로 변환하기
- 날짜범위 가져오기
```

그럼 이 기능을 토대로 인터페이스를 만든다. 초기 이름은 MomentHelper로 지었다. 일단 자주사용되는 인터페이스만 만들어본다.
```ts
class MomentHelper {
  addDate (date: string, count: number, format: FORMAT): string {}
  subtractDate (date: string, count: number, format: FORMAT): string {}
  getToday (format: FORMAT): string {}
  getYesterday (format: FORMAT): string {}
  isSameDate (srcDate: string, targetDate: string): boolean {}
  isSameMonth (srcDate: string, targetDate: string): boolean {}
  isSameYear (srcDate: string, targetDate: string): boolean {}
  isLeapYear (date: string): boolean {}
}
```
그리고 중요한 것은 **실제로 사용할 코드에서 인터페이스를 사용**해보는 것이다. 인터페이스를 설계해도 실제로 사용되는 곳에서 사용해보는 것이 좋다. 실제로 사용했을 때 원하는 방향으로 설계가 됬는 지 그리고 깔끔하게 설계가 되었는 지 알 수 있다. 그리고 인터페이스만 변경해보면서 중복적인 요소가 보이면서 필요한 기능을 또 식별할 수 있다.

### 개발하기
공통 코드는 공통의 사용을 목적으로 하고 사용측이 많기 때문에 안전성이 보장되야 한다. 그래서 테스트 코드를 작성하는 게 중요하다. 테스트 코드를 통해 메소드들이 어떻게 동작하는 지 스펙을 작성한 뒤 동작하는 코드를 작성해야 한다.

테스트 코드는 유닛 테스트 라이브러리를 사용해도 좋고 동작 여부를 확인하는 함수를 별도로 작성해도 좋다. 프로젝트는 Karma + Jasmine으로 환경이 구성되서 그대로 사용했다.

테스트 코드는 이런 형태로 작성했다.
```js
describe('addDate', () => {
  it('addDate - 기본 포맷', () => {
    // Given
    const DATE = '2019-03-01 10:25:30'
    const COUNT = 1

    // When
    const result = service.addDate(DATE, COUNT)

    // Then
    expect(result).toBe('2019-03-02')
  })
})
```

간단하게 설명하면 이렇게 정의한다.
```
- describe: 테스트할 함수 정의
- it: 동작 케이스 또는 시나리오 작성
- Given: 주어진 값, 전재를 의미
- When: 함수 실행
- Then: 의도한 결과
```

테스트를 작성한 뒤 moment를 사용해서 함수 내부를 작성한다. 테스트 코드 동작을 통해 함수가 정상적으로 동작하는 지 빠르게 피드백을 받을 수 있다. 이 과정을 반복하면서 하나씩 기능을 추가하면 안전성이 보장된 코드를 작성할 수 있다.

```ts
@Injectable()
export class MomentHelper {
  addDate (date: string, count: number, format: FORMAT = DEFAULT_FORMAT): string {
    return moment(date)
      .add(count, 'days')
      .format(format)
  }
}
```

모든 인터페이스를 개발하면 리팩토링한다. 테스트 코드를 통해 안전성이 보장된다. 리펙토링 중에 오류가 발생해도 테스트 코드를 통해 바로 피드백을 받을 수 있다. 리팩토링은 상수화, 공통로직을 메소드화, 네이밍 수정 등이 이뤄진다.

### 적용하기
적용할 때는 타입을 먼저 변경했다. 타입 스크립트를 사용하는 중인데 타입 스크립트는 잘못된 타입을 사용하면 바로 피드백해준다. 그래서 Date, number를 사용하는 위치에 string으로 변경해서 영향있는 곳을 파악했다.

#### 컴포넌트 통신 구간 적용
컴포넌트간의 통신 데이터로 Date나 Timestamp를 사용할 때가 있는 데, string 타입으로 변경이 필요하다. 이 때는 먼저 서로 의존성을 끊는 게 중요하다.

A와 B 컴포넌트들이 Date 타입은 today 변수가 있다고 가정하겠다. 두 컴포넌트 간의 통신 데이터로 Date 타입을 사용한다.
```
[A] (today: Date)---(Date Type)---(today: Date) [B]
```
A에서 today를 string으로 수정하면 B에 영향이 생긴다. 그래서 A의 today를 수정하기 위해서는 통신 시점에 변환이 필요하다.
```
[A] (today: string)=>(outputToday: Date)---(Date Type)---(today: Date) [B]
```
이렇게 되면 A 컴포넌트 내부의 날짜 데이터들은 모두 string으로 변경 가능하다. A 컴포넌트 변경 완료 후에 B 컴포넌트의 변경을 한다. B 컴포넌트에 헬퍼를 적용할 때도 유사하다. Date를 전달받고 string으로 변환하여 B 컴포넌트도 헬퍼를 적용한다.
```
[A] (today: string)=>(outputToday: Date)---(Date Type)---(inputToday: Date)=>(today: string) [B]
```

그리고 모두 완료되면 통신 구간을 변경한다. 이렇게 하면 오류를 발생시키지 않고 적용 가능하다.
```
[A] (today: string)---(string Type)---(today: string) [B]
```