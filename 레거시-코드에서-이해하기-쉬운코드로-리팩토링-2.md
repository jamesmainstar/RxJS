### 글의 목적
구조적인 개선을 진행한 뒤 코드적인 부분만 개선이 필요할 때가 있다.
현실세계의 문제는 우리가 기초문법학습할 때와 다르게 복잡성을 가지고 있다.
현실세계에서 사용되는 코드를 이해하기 쉬운코드를 작성하고 **함수형의 함수**을 통해 개선하는 방법을 다룬다.

### 용어정의
- 책임연쇄패턴
  - 문제를 처리에 적합한 객체를 연쇄적으로 찾아 책임을 부여하는 패턴이다.
  - 메세지를 보내는 객체와 이를 처리하는 객체의 결합도를 줄이기 위한 패턴이다.

### 해체/할당
#### 객체 추출하여 다른 객체 만들기
객체에서 특정한 프로퍼티만 추출하여 다른 객체를 만들고 싶을 때가 있다.
새로운 객체를 만들어 객체의 값을 할당하는 형태이다. 이해하기 어렵지 않지만 **변수사용의 중복**이 발생한다.
```js
const httpBody = {
  name: chatBot.name,
  fallbacks: chatBot.fallbacks,
  config: chatBot.config,
  tags: chatBot.tags,
}
```
해체를 통해 프로퍼티을 추출하고 할당하는 방식을 사용하면 중복을 줄일 수 있다.
```js
const {name, fallbacks, config, tags} = chatBot
const httpBody = {name, fallbacks, config, tags}
```
만약에 프로퍼티의 중복을 줄이고 싶으면 **함수형의 pick함수**를 사용하면 된다.
```js
const httpBody = pick(['name', 'fallbacks', 'config', 'tags'], chatBot)
```
```js
const pick = (keys, obj) => keys
  .map(key => ({[key]: obj[key]}))
  .reduce((acc, obj) => Object.assign(acc, obj))
```
#### 깊은 객체 비교
config.source.appId와 config.target.appId가 다른지를 비교하는 함수이다.
각 프로퍼티가 없을 때 반환을 하여 안전하게 비교가능하게 작성한 코드이다.
source, target의 유무와 각 appId의 유무를 확인하고 appId를 비교하는 등 많은 기능으로 해석하기 힘들게 한다.
```js
const isSameAppId = config => {
  const {source, target} = config
  if (!target || !target.appId || !source || !source.appId) {
    return false
  }
  return target.appId !== source.appId
}
```
해제에 **기본값**을 사용하면 가장 얕은 프로퍼티의 유무를 확인 할 필요없이 작성이 가능하다.
그래서 의도에 맏는 appId를 중심으로 표현이 가능하다.
```js
const isSameAppId = config => {
  const {source = {}, target = {}} = config
  if (target.appId && source.appId) {
    return target.appId !== source.appId
  }
  return false
}
```

### 조건문
#### 동일한 값을 비교할 경우
**if/else**로 작성되면 에러코드에 따른 동작을 파악하기 위해 시선이
**Z형태**(**errorCode -> 211 -> navigate**)로 이동되어 한번에 읽기 어렵게 한다.
```js
if (errorCode === 211) {
  navigate('/signup')
} else if (errorCode === 208) {
  navigate('/user/registration')
} else if (errorCode === 202) {
  navigate('/home')
} else if (errorCode === 212 || errorCode === 213) {
  navigate('/signup')
} else {
  navigate('/login')
}
```
**switch/case**로 작성되면 에러코드와 동작이 **수직**으로 위치하여 시선이 수직으로 이동되어 읽기 쉽게 만든다.
그리고 숫자를 작은 것부터 높은 순서로 작성하고 동일한 동작을 하는 코드는 같이 작성하였다.
```js
switch (errorCode) {
  case 202: navigate('/home')
    break
  case 208: navigate('/user/registration')
    break
  case 211:
  case 212:
  case 213: navigate('/signup')
    break
  default: navigate('/login')
    break
}
```
#### 다른 값을 비교할 경우
조건문에 다른 값들을 비교할 때이다. 결과에 따라 각자 다른 동작을 하고 있다.
일관성이 없기 때문에 읽기 어렵고 이해하기 쉽게 작성되어 있다.
```js
if (error.httpStatus === 0) {
  openToast('알 수 없는 오류가 발생했습니다.')
} else if (error.response && error.response.name === 'TimeoutError') {
  openToast('타임아웃이 발생했습니다.')
} else if (error.code === 211) {
  navigate('/signup')
} else if (error.code === 208) {
  navigate('/user/registration')
} else {
  navigate('/login')
}
```

먼저 **switch/case**를 통해 **책임연쇄패턴**을 작성하여 조건문과 동작을 동일 시선상으로 만들 수 있다.
```js
switch (true) {
  case error.httpStatus === 0:
    openToast('알 수 없는 오류가 발생했습니다.')
    break
  case error.response && error.response.name === 'TimeoutError':
    openToast('타임아웃이 발생했습니다.')
    break
  case error.code === 211:
    navigate('/signup')
    break
  case error.code === 208:
    navigate('/user/registration')
    break
  default:
    navigate('/login')
    break
}
```
그리고 마지막으로 조건문을 함수로 만들면 일관성있는 코드가 작성되어 이해하기 쉽게 한다.
```js
const isUnknownError = error => error.httpStatus === 0
const isTimeoutError = error => error.response && error.response.name === 'TimeoutError'
const isUnregist = error => error.code === 211
const isUnauth = error => error.code === 208

switch (true) {
  case isUnknownError(error):
    openToast('알 수 없는 오류가 발생했습니다.')
    break
  case isTimeoutError(error):
    openToast('타임아웃이 발생했습니다.')
    break
  case isUnregist(error):
    navigate('/user/registration')
    break
  case isUnauth(error):
    navigate('/signin')
    break
  default:
    navigate('/login')
    break
}
```

#### 특정 값이 존재할 때 할당하는 경우
응답에러와 응답메시지가 있을 때 메시지변수에 할당을 하고, 둘다 없을 경우 공통 메시지를 할당하는 코드이다.
간단한 코드지만 메세지변수를 **let**으로 선언하여 **변경가능성**을 표현하였고,
시선이 한방향으로 흐르지 않고 있다.
```js
let message
if (response.error) {
  message = response.error
} else if (response.message) {
  message = response.message
} else {
  message = COMMON_MESSAGE
}
```
**OR**를 통해 작성하면 참일 때 메세지변수에 할당하게 된다.
메세지변수의 **불변**으로 선언하였고, 시선이 한방향으로 흐르게 하였다.
```js
const message = response.error || response.message || COMMON_MESSAGE
```
#### 각 인자값 분기
Angular의 HttpParams를 사용하여 쿼리스트링을 만드는 함수이다.
인자의 존재 유무에 따라 파라미터의 추가가 결정된다.
다른 값이 사용되어 각 값마다 분기가 사용되어 로직이 중복된다.
```js
const convertToParams = ({botName, status, page, pageSize}) => {
  let params = new HttpParams()
  if (botName) {
    params = params.append('botName', botName)
  }
  if (status) {
    params = params.append('status', String(status))
  }
  if (page) {
    params = params.append('page', String(page))
  }
  if (pageSize) {
    params = params.append('size', String(pageSize))
  }
  return params
}
```