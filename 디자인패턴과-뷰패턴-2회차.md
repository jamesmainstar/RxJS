### 객체지향개발의 학술적 조건
1. 대체가능성
2. 내적일관성
```js
const Parent = class {}
const Child = class extends Parent {}
const a = new Child()
console.log(a instanceof Parent);
```
Child는 Parent를 대체할 수 있다는 것을 의미하며, 자바스크립트에서는 프로토타입 체이닝으로 구현하였다.

3. 내적동질성
태생을 그대로 유지할려는 성격
```js
const Parent = class {
  wrap() { this.action() }
  action() { console.log("Parent") }
}
const Child = class extends Parent {
  action() { console.log("Child") }
}
const a = new Child();
a.wrap(); // output: Child
```

### 알고리즘 분화 시 객체지향에서 선택할 수 있는 두가지 방법
데이터가 변경되었을 때와 로직이 변경되었을 때는 해결하는 방법
#### 상속 위임
> 속도와 효율이 좋아짐

내부계약관계로 추상층에서 `공통 요소`를 해결하고 상태를 공유할 수 있음
```js
class Parent {
  constructor() {
    this._base = 'http://web.com';
  }
  load(path) {
    this._load();
  }
  _load() {
    throw 'override!'
  }
}
class Child1 extends Parent {
  _load() {}
}
class Child2 extends Parent {
  _load() {}
}
```
**탬플릿 패턴**을 통해 각각 행동이 기술된 사용자형을 통해 구현한다.

#### 소유 위임
> 메모리를 많이 쓰게 됨

외부계약관계로 각각이 `독립적인 문제`를 해결하며 메시지를 주고 받는 것으로 문제를 해결함

```js
class Parent {
  constructor() {
    this._base = 'http://web.com';
  }
  load(path) {
    this._parser(path);
  }
  set parser(v){
    this._parser = v;
  }
}
```
```js
const parent = new Parent();
parent.parser = loadImage;
parent.load();

parent.parser = loadMarkdown;
parent.load();
```
**전략 패턴**을 통해 사용자형의 인스턴스 하나로 알고리즘만 변경해서 사용가능하다.
하지만 숙련도가 부족하면 추적하기 힘들다.

```js
class Parent {
  constructor() {
    this._base = 'http://web.com';
  }
  load(path) {
    this._parser[0](path, ...this.parent[1]);
  }
  setParser(f, ...args){
    this._parser = [f, arg];
  }
}
```
```js
const parent = new Parent();
parent.setParser(loadImage, ['png', 'jpeg']);
parent.load();

parent.setParser(loadMarkdown, ['title', 'description']);
parent.load();
```
**커맨드 패턴** invoker를 통해 실행기 등록자를 통해 등록한 명령어를 실행한다.

#### 라우팅 테이블
분기분을 삭제할 수 없기 때문에 우회적인 방법을 사용한다. 경우의 수 만큼은 라우팅 테이블을 만들어
필요할 때 키를 통해 접근한다.

