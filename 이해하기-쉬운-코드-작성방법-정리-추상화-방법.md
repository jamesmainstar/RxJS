
### 추상화 방법
- 사람는 한번에 서너개 일만 생각할 수 있다고 합니다.
- 즉, 코드의 표현이 커지면 이해하기 더 어렵습니다.

#### 하위 문제를 추출하는 방법
- 함수 목적은 무엇인가?
- 함수내의 라인마다, 이 라인은 필요하지만 직접적으로 상관없는 하위문제를 해결하는 가?

함수의 목적과 라인은 직접적으로 관련되지 않으면 하위 문제로 추출합니다.


#### 3_1. 설명 변수
- 커다란 표현을 쪼개는 가장 쉬운 방법은 작은 하위 표현을 담을 추가 변수를 만드는 것
- 하위표현의 의미를 설명하므로 **설명 변수**라고도 함
```js
// Not Cool
if (line.split(':')[0] === "root") {}

// Cool
const username = line.split(':')[0]
if (username === "root") {}
```

#### 3_2. 거대한 함수 추출
- 상위수준 목적은 주어진 점과 가장 가까운 장소를 찾는 것
- 코사인의 특별법칙 공식을 사용하는 부분은 하위문제로 추출 가능

```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const latRad = radians(lat)
    const lngRad = radians(lng)
    const lat2Rad = radians(array[i].latitude)
    const lng2Rad = radians(array[i].longitude)
    
    const dist = Math.acos(Math.sin(latRad) * Math.sin(lat2Rad) + Math.cos(latRad) * Math.cos(lat2Rad) * Math.cos(lng2Rad - lngRad))
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```


#### 3_2_1. 직접 상관없는 하위문제
루프의 내부에 있는 코드는 대부분 주요 목적과 직접 상관없는 하위문제를 다룸
```js
const sphericalDistance = (lat1, lng1, lat2, lng2) => {
  const latRad = radians(lat1)
  const lngRad = radians(lng1)
  const lat2Rad = radians(lat2)
  const lng2Rad = radians(lng2)
    
  return Math.acos(
    Math.sin(latRad) * Math.sin(lat2Rad) +
    Math.cos(latRad) * Math.cos(lat2Rad) *
    Math.cos(lng2Rad - lngRad)
  )
}
```


#### 3_2_2. 하위 문제 추출 결과
이제 원래 코드는 이렇게 변한다.
```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const dist = sphericalDistance(lat, lng, array[i].latitude, array[i].longitude)
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```
- 밀도 높은 기하 공식에 방해받지 않음
- 상위수준의 목적에 집중
- 전반적으로 코드의 가독성이 높아짐

---

## 3_3. 기존의 인터페이스를 단순화하기
- 라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아함
- 자신이 사용하는 인터페이스가 깔끔하지 않다면 
- `Wrapper`로 보완할 수 있음

#### 3_3_1. 예) 자바스크립트가 브라우저 쿠키
- 자바스크립트가 브라우저 쿠키를 다루는 방식은 이상적이지 않다. 
- 개념적으로 보면 **쿠키**는 **이름/값** 짝으로 이루어진다. 
- 브라우저가 제공하는 인터페이스는 다음과 같은 문법으로 된 하나의 `document.cookie`를 사용한다.

```
name1=value1; name2=value2; ...
```

#### 3_3_2. 필요한 쿠키 찾으려면...
필요한 쿠키를 찾으려면 이 거대한 문자열의 구문분석을 직접 수행해야 한다.
다음은 `max_results`라는 이름을 가진 쿠키의 값을 읽는 코드이다.

```js
let maxResults
const cookies = document.cookie.split(';')
for (let i = 0, len = cookies.length; i < len; i++) {
  const cookie = cookies[i].replace(/^[ ]+/, '')
  if (cookie.indexOf('max_results') === 0) {
    maxResults = Number(cookie.substring(12, cookie.length))
  }
}
```

#### 3_3_3. 이상적인 인터페이스 만들기
- 이상적이지 않은 인터페이스를 그냥 받아들일 이유가 없다
- 이런 인터페이스가 있으면 언제나 이를 둘러싸는 함수를 작성하여 지저분한 내부를 감출 수 있다.

```js
const getCookie = name => {
  const cookies = document.cookie.split(';')
  for (let i = 0, len = cookies.length; i < len; i++) {
    const cookie = cookies[i].replace(/^[ ]+/, '')
    if (cookie.indexOf(name) === 0) {
      return cookie.substring(name.length + 1, cookie.length)
    }
  }
}
const maxResults = Number(getCookie('max_results'))
```