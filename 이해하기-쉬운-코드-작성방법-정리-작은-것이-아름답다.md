### 작은 것이 아름답다
작은 소프트웨어는 단순하고 다루기 쉬우며 큰 소프트웨어보다 훨씬 뛰어나다. 따라서 소프트웨어는 작게 만들고 작게 유지하도록 한다.

작은 소프트웨어는 다음과 같은 장점이 있다.
1. 이해가 쉽다.
2. 수정이 쉽다.
3. 다른 소프트웨어와 조합하기 쉽다.

반면에 큰 소프트웨어는 다음과 같은 문제가 있다.
1. 복잡하고 코드를 이해하기 어렵다.
2. 예측하지 못하고 사태에 대응하기 힘들다.

#### 한 번에 하나의 작업
가장 좋은 소프트웨어란 생애 중에 단 하나의 작업만을 제대로 완수하는 소프트웨어다. 하나의 작업에 집중함으로써 코드에 불필요한 부분을 없앨 수 있다.

하나의 작업에 집중함으로써 해당 작업의 본질을 파악할 수 있다. 하나의 작업을 제대로 하는 소프트웨어를 만들 수 없다면 문제를 아직 완전하게 이해하지 못했다는 뜻이다.

#### 하위 문제를 추출하는 방법
- 함수 목적은 무엇인가?
- 함수내의 라인마다, 이 라인은 필요하지만 직접적으로 상관없는 하위문제를 해결하는 가?

함수의 목적과 라인은 직접적으로 관련되지 않으면 하위 문제로 추출합니다.


#### 설명 변수
커다란 표현을 쪼개는 가장 쉬운 방법은 작은 하위 표현을 담을 추가 변수를 만드는 것이다. 하위표현의 의미를 설명하므로 설명 변수라고도 한다.

```js
// Not Cool
if (line.split(':')[0] === "root") {}

// Cool
const username = line.split(':')[0]
if (username === "root") {}
```

#### 거대한 함수 추출
개별적인 표현은 그렇게 크지 않지만, 모두 한 곳에 있어서 코드를 읽는 사람의 머리를 강타하는 거대한 구문을 형성한다.

다행히도 표현하는 많은 부분이 동일하다. 따라서 동일한 부분을 요약 변수로 추출해서 함수의 앞부분에 놓아둘 수 있다.
```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const latRad = radians(lat)
    const lngRad = radians(lng)
    const lat2Rad = radians(array[i].latitude)
    const lng2Rad = radians(array[i].longitude)
    
    const dist = Math.acos(Math.sin(latRad) * Math.sin(lat2Rad) + Math.cos(latRad) * Math.cos(lat2Rad) * Math.cos(lng2Rad - lngRad))
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```


#### 3_2_1. 직접 상관없는 하위문제
루프의 내부에 있는 코드는 대부분 주요 목적과 직접 상관없는 하위문제를 다룸
```js
const sphericalDistance = (lat1, lng1, lat2, lng2) => {
  const latRad = radians(lat1)
  const lngRad = radians(lng1)
  const lat2Rad = radians(lat2)
  const lng2Rad = radians(lng2)
    
  return Math.acos(
    Math.sin(latRad) * Math.sin(lat2Rad) +
    Math.cos(latRad) * Math.cos(lat2Rad) *
    Math.cos(lng2Rad - lngRad)
  )
}
```


#### 3_2_2. 하위 문제 추출 결과
이제 원래 코드는 이렇게 변한다.
```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const dist = sphericalDistance(lat, lng, array[i].latitude, array[i].longitude)
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```
- 밀도 높은 기하 공식에 방해받지 않음
- 상위수준의 목적에 집중
- 전반적으로 코드의 가독성이 높아짐

#### 3_3. 기존의 인터페이스를 단순화하기
- 라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아함
- 자신이 사용하는 인터페이스가 깔끔하지 않다면 
- `Wrapper`로 보완할 수 있음

#### 3_3_1. 예) 자바스크립트가 브라우저 쿠키
- 자바스크립트가 브라우저 쿠키를 다루는 방식은 이상적이지 않다. 
- 개념적으로 보면 **쿠키**는 **이름/값** 짝으로 이루어진다. 
- 브라우저가 제공하는 인터페이스는 다음과 같은 문법으로 된 하나의 `document.cookie`를 사용한다.

```
name1=value1; name2=value2; ...
```

#### 3_3_2. 필요한 쿠키 찾으려면...
필요한 쿠키를 찾으려면 이 거대한 문자열의 구문분석을 직접 수행해야 한다.
다음은 `max_results`라는 이름을 가진 쿠키의 값을 읽는 코드이다.

```js
let maxResults
const cookies = document.cookie.split(';')
for (let i = 0, len = cookies.length; i < len; i++) {
  const cookie = cookies[i].replace(/^[ ]+/, '')
  if (cookie.indexOf('max_results') === 0) {
    maxResults = Number(cookie.substring(12, cookie.length))
  }
}
```

#### 3_3_3. 이상적인 인터페이스 만들기
- 이상적이지 않은 인터페이스를 그냥 받아들일 이유가 없다
- 이런 인터페이스가 있으면 언제나 이를 둘러싸는 함수를 작성하여 지저분한 내부를 감출 수 있다.

```js
const getCookie = name => {
  const cookies = document.cookie.split(';')
  for (let i = 0, len = cookies.length; i < len; i++) {
    const cookie = cookies[i].replace(/^[ ]+/, '')
    if (cookie.indexOf(name) === 0) {
      return cookie.substring(name.length + 1, cookie.length)
    }
  }
}
const maxResults = Number(getCookie('max_results'))
```