### 작은 것이 아름답다
**작은 소프트웨어**는 단순하고 다루기 쉬우며 **큰 소프트웨어**보다 훨씬 뛰어나다. 따라서 소프트웨어는 작게 만들고 작게 유지하도록 한다.

작은 소프트웨어는 다음과 같은 장점이 있다.
1. 이해가 쉽다.
2. 수정이 쉽다.
3. 다른 소프트웨어와 조합하기 쉽다.

반면에 큰 소프트웨어는 다음과 같은 문제가 있다.
1. 복잡하고 코드를 이해하기 어렵다.
2. 예측하지 못하고 사태에 대응하기 힘들다.

#### 설명 변수
커다란 표현을 쪼개는 가장 쉬운 방법은 작은 하위 표현을 담을 추가 변수를 만드는 것이다. 하위표현의 의미를 설명하므로 **설명 변수**라고도 한다.

```js
// Not Cool
if (line.split(':')[0] === "root") {}

// Cool
const username = line.split(':')[0]
if (username === "root") {}
```

#### 상관없는 하위문제 추출하기
엔지니어링은 커다란 문제를 작은 문제들로 쪼갠 다음, 각각의 문제에 대한 해결책을 구하고, 다시 하나의 해결책으로 맞추는 일련의 작업을 한다.
이러한 원리를 코드에 적용하면 코드가 더 튼튼해지며 가독성도 좋아진다.
큰 흐름과 관계가 적은 하위문제를 적극적으로 발견해서 추출하라는 것이다. 이 말이 의미하는 바는 다음과 같다.

1. 주어진 함수가 코드 블록을 보고, 스스로에게 질문하라 **상위수준에서 본 이 코드의 목적은 무엇인가?**
2. 코드의 모든 줄에 질문을 던져라 **이 코드는 직접적으로 목적을 위해서 존재하는 가?** 혹은 **목적을 위해서 필요하긴 하지만 목적 자체와 직접적으로 상관없는 하위문제를 해결하는가?**
3. 만약 상당히 원래의 목적과 직접적으로 관련되지 않은 하위문제를 해결하는 코드 분량이 많으면, 이를 추출해서 별도의 함수로 만든다.

다음 자바스크립트 코드의 **상위수준 목적**은 주어진 점과 가장 가까운 장소를 찾는 것이다.
```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const latRad = radians(lat)
    const lngRad = radians(lng)
    const lat2Rad = radians(array[i].latitude)
    const lng2Rad = radians(array[i].longitude)
    
    // 코사인의 특별법칙 공식을 사용한다.
    const dist = Math.acos(
      Math.sin(latRad) * Math.sin(lat2Rad) +
      Math.cos(latRad) * Math.cos(lat2Rad) *
      Math.cos(lng2Rad - lngRad)
    )
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```
루프의 내부에 있는 코드는 대부분 주요 목적과 **직접 상관없는 하위문제**를 다룬다.

```js
const sphericalDistance = (lat1, lng1, lat2, lng2) => {
  const latRad = radians(lat1)
  const lngRad = radians(lng1)
  const lat2Rad = radians(lat2)
  const lng2Rad = radians(lng2)
    
  return Math.acos(
    Math.sin(latRad) * Math.sin(lat2Rad) +
    Math.cos(latRad) * Math.cos(lat2Rad) *
    Math.cos(lng2Rad - lngRad)
  )
}
```
이제 원래 코드는 이렇게 변한다.
```js
const findClosestLocation = (lat, lng, array) => {
  let closest
  let closestDist = Number.MAX_VALUE
  
  for (let i = 0, len = array.length; i < len; i++) {
    const latRad = radians(lat)
    const lngRad = radians(lng)
    const lat2Rad = radians(array[i].latitude)
    const lng2Rad = radians(array[i].longitude)
    
    // 코사인의 특별법칙 공식을 사용한다.
    const dist = sphericalDistance(lat, lng, array[i].latitude, array[i].longitude)
    
    if (dist < closestDist) {
      closest = array[i]
      closestDist = dist
    }
  }
  return closest
}
```
코드를 읽는 사람도 밀도 높은 기하 공식에 방해받지 않고 **상위수준의 목적에 집중**할 수 있으니 전반적으로 코드의 가독성이 높아졌다.

#### 기존의 인터페이스를 단순화하기
라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아한다.
하지만 자신이 사용하는 인터페이스가 깔끔하지 않다면, 깔끔한 **덮개**(Wrapper)로 보완할 수 있다.

예를 들어 자바스크립트가 브라우저 쿠키를 다루는 방식은 전혀 이상적이지 않다. 개념적으로 보면
쿠키는 이름/값 짝으로 이루어진다. 브라우저가 제공하는 인터페이스는 다음과 같은 문법으로 된
하나의 `document.cookie`를 사용한다.

```
name1=value1; name2=value2; ...
```

필요한 쿠키를 찾으려면 이 거대한 문자열의 구문분석을 직접 수행해야 한다.
다음은 `max_results`라는 이름을 가진 쿠키의 값을 읽는 코드이다.

```js
let maxResults
const cookies = document.cookie.split(';')
for (let i = 0, len = cookies.length; i < len; i++) {
  const cookie = cookies[i].replace(/^[ ]+/, '')
  if (cookie.indexOf('max_results') === 0) {
    maxResults = Number(cookie.substring(12, cookie.length))
  }
}
```

정말 지저분한 코드다. 다음과 같이 사용할 수 있는 `get_cookie()`함수를 만들어야 할 것 처럼 보인다.

```js
const maxResults = Number(getCookie('max_results'))
```

여기서 **이상적이지 않은 인터페이스를 그냥 받아들일 이유가 없다**는 교훈을 얻을 수 있다.
이런 인터페이스가 있으면 언제나 이를 둘러싸는 함수를 작성하여 지저분한 내부를 감출 수 있다.