### 글의 목적
함수나 클래스 레벨의 코드를 수정하는 것은 굉장히 빈번하게 발생하고 익숙한 작업이다.
하지만 구조 레벨을 수정하는 것은 빈번하지 않고 큰 비용이 발생하는 작업이다.

**구조 리펙토링**은 함수와 클래스 로직을 수정하지 않고
컴포넌트, 파일, 폴더를 역할과 책임 그리고 이해하기 쉬운 형태로 재정렬하는 것이다.
이 포스트에서는 **컴포넌트 구조 리펙토링**을 다룬다.

이해하기 쉬운 코드와 소프트웨어 철학을 학습했는 데도 불구하고 시간적인 여유가 없어
구조적인 리펙토링을 진행못할 때가 많다.
개인적으로 싫어하는 **탁상곤론**을 벗어나 구조레벨의 리펙토링을 진행하였고,
관련해서 기본적인 방법들을 정리하고자 작성한 포스트이다.

### 표기정의
#### ngFor
Angular에서 사용하는 **리스트 렌더링 문법**이다. vue에서는 `v-for`를 사용한다.

#### 조건문
조건문은 `[foo=bar]`과 같은 형태로 정의한다.
조건문의 왼쪽은 질문을 받는 표현을 정의하고, 오른쪽에는 비교대상을 정의한다.

#### 컴포넌트 표기
여기서 컴포넌트를 표현할 때는 박스를 통해서 표현한다. 컴포넌트의 내부에서 정의된 기능들을 `<feature>`로 표현하겠다.

![](https://chodragon9.github.io/assets/img/structure-refactoring/1.png)

### 컴포넌트 리펙토링 과정
PageComponent라는 페이지를 그려주는 컴포넌트를 예를 들어 리펙토링 과정을 설명한다.

#### AS IS 모습
![](https://chodragon9.github.io/assets/img/structure-refactoring/2.png)
PageComponent는 헤더, 사이드 네비게이션, 타임라인 콘텐츠, 온라인중인 친구리스트로 구성된다.
PageComponent의 개선포인트는 3가지가 있다.

**첫번째**는 상위레벨에서 하위레벨의 역할을 수행하고 있는 것이다.
여기서는 네비게이션을 숨기는 기능을 PageComponent에서 다루고 있고, SideNaviComponent로 이동이 필요하다.

**두번째는**는 컴포넌트화가 필요한 볼륨이 컴포넌트화가 안되있고, 복잡성을 증가하는 부분이다.
여기서는 타임라인을 구체적으로 표시하는 방법을 PageComponent에서 다루고 있어,
타임라인을 표시를 의미하는 컴포넌트 생성이 필요하다.

**세번째**는 하위레벨의 의미가 모호한 것이다.
온라인중인 친구리스트 기능을 담당하는 OnlineListComponent가 **컴포넌트 네이밍이 모호**하여 네이밍 변경이 필요하다.

#### 리펙토링을 위한 준비
리펙토링을 시작하기 앞서 설계작업을 하는 게 좋다. 현실적인 방법이 아닌 이상적인 구조로 설계를 한다.
이상적인 구조는 이해하기 쉽고, 역할을 명확히 알 수 있게 구분하는 작업이다.

![](https://chodragon9.github.io/assets/img/structure-refactoring/3.png)
개선 포인트를 반영하여 **재설계**한 구조이다. 먼저 PageComponent에서는 컴포넌트로 추상화된 UI들로 구성된다.
UI 상으로 구분되어있는 부분들을 컴포넌트에도 반영한 것이다.

네비게이션을 숨기는 기능은 SideNaviComponent 내부로 이동되었다.
SideNaviComponent에서 관리해야 할 상태와 로직을 PageComponent로 이동하여
PageComponent는 SideNaviComponent를 사용하는 것만 담당하게 된다.

`{timelineDatas}`를 구체적으로 기술하는 부분을 위해 TimelineComponent를 만들었다.
TimelineComponent에서 `{timelineDatas}` 데이터를 다루게 되고,
PageComponent는 구체적인 부분을 다룰 필요가 없어졌다. 

OnlineListComponent는 **온라인중인 친구리스트**라는 의미를 명확히 하기 위해
OnlineFriendsComponent으로 네이밍이 변경됬다.

#### 구조 리펙토링 과정
![](https://chodragon9.github.io/assets/img/structure-refactoring/4.png)
리펙토링을 시작할 때는 먼저 볼륨이 작거나 쉽게 수정이 가능한 부분부터 해결한다.
여기서는 네이밍 변경과 역할을 이동하는 부분부터 진행한다.
![](https://chodragon9.github.io/assets/img/structure-refactoring/5.png)
이제 볼륨이 큰 부분을 작업한다. 컴포넌트를 생성하여 다른 컴포넌트에 이동하는 작업은 많은 작업을 동반하기 때문에 유의해야 한다.
이렇게 완료를 하면 한싸이크이 완료가 된다.

#### 구체적인 구조 리펙토링 과정
구체적으로 코드레벨에서는 아래와 같은 순서로 진행된다.
1. 마크업 옮기기
   - 마크업 부분을 복사&붙여넣기한다. 기능 동작을 확인해야 함으로 원본을 유지한다.
2. 마크업에서 사용되는 변수와 메소드 이동
   - 가장 위에 있는 라인부터 필요한 메소드를 찾아 이동할 위치에 복사&붙여넣기를 한다.
   - 에디터를 통해 옮기지 않은 부분이 있는 지 확인한다.
3. 기능확인
   - 원본 기능과 비교해 정상동작을 확인한다.
4. 원본 삭제
   - 원본 기능을 삭제하고, 신규로 옮긴 부분만 남긴다.
5. 커밋
   - 소스 커밋을 할 때는 앞에 `[리펙토링]`으로 시작하여 로그를 남기면 리펙토링 관련해서 로그를 파악하기 용이하다.
   
#### 중복코드가 발생될 때
PageComponent로 부터 컴포넌트를 만들때 생성된 컴포넌트나 역할이 이동된 컴포넌트에 중복된 코드가 생성될 수 있다.
구조레벨 수정중에 중복된 코드가 보여도 구조레벨 수정 완료후에 한번에 진행하는 것을 권한다.
중복 코드를 수정하는 작업은 코드레벨의 리펙토링이다.
다른 작업을 병렬적으로 작업하게 되면 실수할 여지가 있으므로 구조레벨의 리펙토링이 완료 후에 하는 것이 권한다.

### 실제로 리펙토링한 부분
UI 상으로는 이런 형태이다.

![](https://chodragon9.github.io/assets/img/structure-refactoring/6.png)
#### 리펙토링 결과
![](https://chodragon9.github.io/assets/img/structure-refactoring/7.png)

### 끝