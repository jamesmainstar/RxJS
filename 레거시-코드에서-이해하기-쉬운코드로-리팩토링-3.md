### 글의 목적
프로젝트 코드를 모두 리뷰를 했을 때 알 수 있는 것은 소프트웨어의 구성은 대부분 **객체 또는 객체간의 관계**, **조건문**, **반복문**으로 이뤄졌다.

여기서 **객체**를 잘 다루기 위해서는 **객채지향 프로그래밍**에 대한 이해가 필요하다.
그리고 **반복문**과 **조건문**을 **if, for**와 같은 복잡한 기능을 사용하지 않기 위해서는 **함수형 프로그래밍**의 이해가 필요하다.

### 카테고리
- [함수형으로 대체 가능한 문법들](#함수형으로-대체-가능한-문법들)

### 함수형으로 대체 가능한 문법들
함수형 개념을 사용하면 **추상화된 함수**를 통해 반복문과 조건문을 최소화할 수 있다. 값을 다루는 방법도 불변값을 다루기 때문에 안전한 값을 다룰 수 있다.

#### Array#reduce
reduce는 각 배열 요소를 주어진 함수의 결과와 누산하여 하나의 결과값을 반환한다.
```js
[1, 2, 3].reduce((acc, v) => v + acc)
// 6
```
이런 형태의 명령형을 대체할 수 있다.
```js
const total = arr => {
  let sum = 0
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i]
  }
  return sum
}
total([1, 2, 3])
// 6
```

#### Array#map
map은 배열의 모든 요소를 주어진 함수의 결과로 변경한 새로운 배열을 반환한다.
```js
[1, 2, 3].map(v => v * 10)
// [10, 20, 30]
```
이런 형태의 명령형을 대체할 수 있다.
```js
const arr = [1, 2, 3]
for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i] * 10
}
console.log(arr)
// [10, 20, 30]
```

#### Array#findIndex
findIndex는 주어진 함수가 Truthy로 평가되는 값을 찾으면 해당 인덱스를 반환한다.
일치하는 게 없을 때는 -1를 반환한다.
```js
[1, 2, 3].findIndex(v => v >= 2)
// 1

[1, 2, 3].findIndex(v => v > 3)
// -1
```
이런 형태의 명령형을 대체할 수 있다.
```js
const findItemIndex = arr => {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < 2) {
      return i
    }
  }
  return -1
}
findItemIndex([1, 2, 3])
// 0
findItemIndex([2, 3])
// -1
```


#### Array#find
find는 주어진 함수가 Truthy로 평가되는 값을 찾으면 해당 값을 반환한다.
일치하는 게 없을 때는 undefined를 반환한다.
```js
[1, 2, 3].find(v => v >= 2)
// 2

[1, 2, 3].find(v => v > 3)
// undefined
```
이런 형태의 명령형을 대체할 수 있다.
```js
const findItem = arr => {
  for (let i = 0; i < arr.length; i++) {
    const item = arr[i]
    if (item < 2) {
      return item
    }
  }
}
findItem([1, 2, 3])
// 1
findItem([2, 3])
// undefined
```

#### Array#filter
filter는 주어진 함수가 Truthy로 평가되는 값만 모아 새로운 배열로 반환한다.
```js
[1, 2, 3].filter(v => v >= 2)
// [2, 3]
```
이런 형태의 명령형을 대체할 수 있다.
```js
const arr = [1, 2, 3]
const newArr = []
for (let i = 0; i < arr.length; i++) {
  const item = arr[i]
  if (item >= 2) {
    newArr.push(item)
  }
}
console.log(newArr) // [2, 3]
```

#### Array#every
every는 모두 일치할 때 true를 반환하고, 하나라도 불일치 할 때 false를 반환한다.
```js
[1, 2, 3].every(v => v <= 3)
// true

[1, 2, 3].every(v => v < 2)
// false
```
이런 형태의 명령형을 대체할 수 있다.
```js
const hasAll = arr => {
  for (let i = 0; i < arr.length; i++) {
    if (!arr[i]) {
      return false
    }
  }
  return true
}
hasAll([1, 2, 3])
// true
hasAll([4, null, 6])
// false
```

#### Array#some
some은 하나라도 일치하는 게 있으면 true를 반환하고, 없을 때 false를 반환한다.
```js
[1, 2, 3].some(v => v > 2)
// true

[1, 2, 3].some(v => v > 3)
// false
```
이런 형태의 명령형을 대체할 수 있다.
```js
const hasItem = arr => {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < 2) {
      return true
    }
  }
  return false
}
hasItem([1, 2, 3])
// true
hasItem([4, 5, 6])
// false
```

#### takeWhile
takeWhile은 주어진 함수의 평가가 Truthy일 때 순회를 멈추가 순회했던 요소들을 새로운 배열에 담아 반환한다.
```js
const takeWhile = (f, arr) => {
  const newArr = []
  arr.some((val, ...args) => {
    const result = !f(val, ...args)
    result || newArr.push(val)
    return result
  })
  return newArr
}
```
```js
takeWhile(a => a, [1, 2, 3, 0, 4, 5])
/// [1, 2, 3]
```
이러한 명령형을 대체할 수 있다.
```js
const arr = [1, 2, 3, 0, 4, 5]
const newArr = []

for (let i = 0; i < arr.length; i++) {
  const item = arr[i]
  if (!item) {
    break
  }
  newArr.push(item)
}

console.log(newArr)
// [1, 2, 3]
```

#### takeUntil
```js
const takeUntil = (f, arr) => {
  const newArr = []
  arr.some((val, ...args) => {
    newArr.push(val)
    return f(val, ...args)
  })
  return newArr
}
```
```js
takeUntil(a => a, [0, false, undefined, null, 1, 2, 3])
// [0, false, undefined, null, 1]
```
이러한 명령형을 대체할 수 있다.
```js
const arr = [0, 0, 0, 0, 4, 5]
const newArr = []

for (let i = 0; i < arr.length; i++) {
  const item = arr[i]
  newArr.push(item)
  if (item) {
    break
  }
}

console.log(newArr)
// [0, 0, 0, 0, 4]
```

#### range
```js
const range = length => Array.from({length}, (_, i) => i)
```
```js
range(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

일반적인 **인덱스 루프**를 대체할 수 있다.
```js
// Not Cool
for (let i = 0; i < 10; i++) {
  console.log(i)
}

// Cool
range(10).forEach(i => console.log(i))
```

#### mapValues
mapValues는 Object의 요소들을 순회하면서 주어진 함수의 평가결과를 value에 할당한다.
```js
const mapValues = (f, obj) => Object
  .entries(obj)
  .map(([k, v]) => ({[k]: f(v)}))
  .reduce((acc, obj) => Object.assign(acc, obj))
```
```js
const obj = {a: 1, b: 2, c: 3}
mapValues(n => n + 10, obj)
// {a: 11, b: 12, c: 13}
```

**for...in**를 대체할 수 있다.
```js
const obj = {a: 1, b: 2, c: 3}
for (const key in obj) {
  obj[key] = obj[key] + 10
}
```