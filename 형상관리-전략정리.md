### 글의 목적
> 형상관리 도구는 Git을 기준으로 설명합니다.

소프트웨어 개발자의 역량으로 코딩을 하는 것 만큼 중요한 역량이 **형상관리 역량**이다.
형상관리 정책에 따라 개발/배포/협업의 형태가 달라진다.
보편적으로는 **깃플로우** 정책을 많이 따르거나 조직에 맞게 변경해서 사용한다.
이때 경험에 따라 커밋 단위, 충돌 대응, 브랜치 전략의 차이를 보인다.

형상관리 도구를 실무에 사용한지 6년정도 되었고, 형상관리 방안에 대해 가이드나 교육을 많이 진행했었다.
최근에도 개발 동료가 증가를 해서 형상관리 가이드가 필요했다.
이 기회에 기억속에 파편화되있는 형상관리 전략에 대한 정리하고자 작성한 포스트이다.

### 먼저 커밋 단위는 어떻게 
커밋하는 단위를 쪼개는 작업는 개발자별로 천차만별이다. 먼저 **추천하는 방법**은 작은 기능 단위로 커밋을 하는 것이다. 작은 기능 단위는 사람마다 다르게 생각을 할 수 있는 데, 나는 잘개쪼갠 사용자 스토리로 커밋을 한다.
##### 사용자 스토리 예시
```
[카톡 프로필 화면]
- 프로필 사진을 클릭하면, 확대된 프로필 사진을 볼 수 있다.
- 배경 사진을 클릭하면, 확대된 배경 사진을 볼 수 있다.
```

이렇게 잘게 나눠진 사용자 스토리면 보편적으로 코드 수정량도 많지 않다. 각 사용자 스토리가 하나의 커밋 단위가 되고, 커밋 메세지가 된다.
이렇게 했을 때 장점은 기능에 문제가 발생했을 때, `revert`, `cherry-pick` 작업을 하거나 기능별 코딩작업을 확인하기 용이하다.

**비추천**방법은 결국 **일하기 힘들어지는 방법**인데, 일하기 힘든 것이라 하면 시간이 많이 들고 실수할 확률이 높은 방법이라고 할 수 있다.
비추천 방법은 **의미없이 커밋**하는 것이다. 두가지 유형을 봐왔는 데, 첫번째는 한작업의 커밋에 다른 작업을 껴서 커밋하는 것이고, 두번째는 사용자 스토리가 무수히 많은 큰 단위의 기능을 하나의 커밋으로 넣는 것이다.

즉, 커밋은 하나의 히스토리를 남기는 작업인데 작업 단위로 `revert`, `cherry-pick` 작업이 힘들게 된다. 더 심각한것은 커밋을 했음에도 기능이 언제 작업됬는 지 확인하기 힘든것이다.

제한된 시간에 개발을 하는 것도 힘든 작업인데, 형상관리에서 문제가 발생하면 시간과 에너지가 많이 소비하게 된다. 되도록 작은 단위로 커밋하는 것을 권하고 싶다.

### 기본적인 깃 플로우
깃 플로우는 하나의 **형상관리 솔루션**이다. 깃 플로우는 병합을 기반으로 개발/배포/핫픽스에 대한 방법론을 제시한다.
일반적인 깃 플로우와 경험적인 내용을 다루는 부분이다. 깃 플로우에 대한 경험이 많다면 이 부분은 넘어가도 된다.

#### 기능 개발
기능 개발은 **feature 브랜치**에서 작업한다. feature 브랜치는 develop 브랜치에서 만들고, 네이밍은 `feature/<기능명 | 이슈 ID>`와 같이한다.
나는 **기능명**은 동사, 명사에 대한 제약은 두지 않고 네이밍을 한다. 브랜치 네이밍도 하나의 컨벤션이기 때문에 규칙을 정하는 것도 하나의 방법이다.
**이슈 ID**는 업무관리 시스템을 사용할 경우 사용된다.

```
[결제페이지] => feature/payment-page
[게시판 글쓰기] => feature/write-board
[버튼 미동작 이슈] => feature/fix-non-operation-button
```

브랜치에서 개발이 완료되면 develop 브랜치에 병합을 하여 완료한다.

#### 배포
배포 시기에는 **release 브랜치**에서 작업한다. release 브랜치도 develop 브랜치에서 만든다. feature 브랜치와 다르게 release 브랜치는 **확실한 네이밍 정책**이 필요하다. 개발기간에 수정된 내역들을 배포하는 것이므로 보편적으로 `release/YYYYMMDD`, `release/<version>`, `release/<스프린트명>`을 사용한다.

release 브랜치에서 QA를 진행 완료 후 배포를 하게 된다. 완료 후에 release 브랜치는 develop과 master 브랜치에 병합되며 배포 태그을 생성하게 된다. 그리고 master 브랜치를 기준으로 서비스 배포를 진행하면 배포가 완료된다.

#### 핫픽스
핫픽스는 배포한 소프트웨어가 비즈니스적으로 문제를 일으키는 이슈를 발생했을 때 즉각 대응하는 방안이다. 큰 이슈가 아닌 이상 핫픽스를 하지 않는 것을 추천하며, 마이너한 버그는 다음 배포시기에 포함하는 게 안정적인 서비스 운영에 도움이 된다.

hotfix 브랜치는 master 브랜치에서 만든다. 네이밍은 보편적으로 `hotfix/fix-<기능명>`으로 사용된다. 기능 수정이 완료되면 hotfix 브랜치는 develop과 master 브랜치에 병합되고 핫픽스 태그를 생성하게 된다.

#### 컴플릭트 대응
병합을 할 때 병합을 받는 쪽에서 같은 파일의 수정이 일어나면 컴플릭트가 발생한다.
feature 브랜치를 develop 브랜치에 병합을 할 때 발생할 확률이 높다.
컴플릭트가 발생되면 feature 브랜치에서 먼저 develop 브랜치를 병합한다.
발생된 컴플릭트 사항들중 동료와 연관있는 기능이라면 꼭 페어 체크를 해야 한다.
그리고 컴플릭트 수정 뒤에 develop 브랜치에 병합을 하면 된다.

### 실무에 발생할만한것
실무에서 흔히 발생되는 형상관리 이슈는 feature 브랜치를 작업할 때 빈번하게 발생한다.
feature 브랜치 전략에 대한 경험적인 내용이다.

#### 기능의 볼륨이 클때
#### 많은 기능을 혼자 개발 할 때
#### 실수로 PR 중인 브랜치에 작업했을 때
#### 기능이 급하게 이번 배포에 안나갈때

### 끝