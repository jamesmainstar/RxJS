### 코드정리
- 논리 정렬은 **읽기 쉽게 흐름제어**를 만드는 것
- 조건, 루프, 흐름을 통제하는 선언문은 코드를 복잡하게 만드는 원인
- 코드를 읽을 때 다시 되돌아가서 코드를 읽지 않아도 되게 만들어야 함

---

#### 2_1. 조건문에서 인수의 순서
```js
// 가독성 좋음
if (length >= 10) {}

// 가독성 낮음
if (10 <= length) {}
```
- 왼쪽 : 질문을 받는 표현
- 오른쪽 : 비교대상
- 이러한 가이드 라인은 영어 어순과 일치한다.

#### 2_2. if/else 블록의 순서
```js
// Not Cool
if (a !== b) {
} else {
}

// Cool
if (a === b) {
} else {
}
```
- `if/else`를 사용하는 경우 부정이 아닌 긍정을 먼저 다루는 게 좋다
- 첫번째 블록을 생각할 때 한번 부정한 값을 생각해야 함으로 긍정부터 다루는 게 좋음
- 생각보다 이런 코드가 많음...


#### 2_3. 중첩을 최소화하기
- 코드의 중첩이 심할 수록 코드를 읽는 사람의 마음속에 존재하는 정신적 스택에 추가적인 조건이 입력됨
- 함수 중간에 반환하기로 중첩을 제거 할 수 있음

```js
// Not Cool
if (userResult === SUCCESS) {
  if (permissionResult !== SUCCESS) {
    reply.writeError('error reading permissions')
  } else {
    reply.writeError('')
  }
} else {
  reply.writeError(userResult)
}

reply.done()
```

#### 2_3_1. 반환하기로 중첩을 제거

```js
// Cool
if (userResult !== SUCCESS) {
  reply.writeError(userResult)
  reply.done()
  return
}

if (permissionResult !== SUCCESS) {
  reply.writeError('error reading permissions')
  reply.done()
  return
}

reply.writeError('')
reply.done()
```

---

#### 2_4. 거대한 구문 나누기
- 개별적인 표현은 그렇게 크지 않지만, 모두 한곳에 있어 읽기 힘들게 함
- 표현하는 많은 부분이 동일
- 동일한 부분을 **요약 변수로 추출**해서 함수의 앞부분에 놓아둘 수 있음

```js
// Not Cool
const updateHighlight = messageNum => {
  if ($(`#vote_value${messageNum}`).html() === "Up") {
    $(`#thumbs_up${messageNum}`).addClass("highlighted");
    $(`#thumbs_down${messageNum}`).removeClass("highlighted");
  } else if ($(`#vote_value${messageNum}`).html() === "Down") {
    $(`#thumbs_up${messageNum}`).removeClass("highlighted");
    $(`#thumbs_down${messageNum}`).addClass("highlihgted"); // Wrong!!
  } else {
    $(`#thumbs_up${messageNum}`).removeClass("highlighted");
    $(`#thumbs_down${messageNum}`).removeClass("highlighted");
  }
}
```

---

### 2_4_1. 요약 변수로 추출
- 우리 뇌는 자연스럽게 **그룹**과 **계층 구조**를 따라서 동작
- 선언문과 조건을 분리
```js
// Cool
const updateHighlight = messageNum => {
  const thumbsUp = $(`#thumbs_up${messageNum}`)
  const thumbsDown = $(`#thumbs_down${messageNum}`)
  const voteValueHtml = $(`#vote_value${messageNum}`).html()
  const ACTIVE_CLASS = "highlighted"

  if (voteValueHtml === "Up") {
    thumbsUp.addClass(ACTIVE_CLASS);
  } else {
    thumbsUp.removeClass(ACTIVE_CLASS);
  }
  if (voteValueHtml === "Down") {
    thumbsDown.addClass(ACTIVE_CLASS);
  } else {
    thumbsDown.removeClass(ACTIVE_CLASS);
  }
}
```

#### 2.5 SLAP(Single Level of Abstraction Principle)
- 단일 수준 추상화 원칙
- 코드를 작성할 때 **높은 수준**과 **낮은 수준**의 추상화 개념을 분리
- 최고 수준부터 중간 수준의 처리가 책의 **목차**가 되고
- 최저 수준의 처리가 책의 **본문 내용**이 됨
- 결과적으로 추상화 수준을 일치시킨 코드는 훌륭한 책
```
function 고수준() { 중수준1(); 중수준2(); } // 수준1의 목차
function 중수준1() { 저수준1(); 저수준2(); } // 수준2의 목자-1
function 저수준1() { }
function 저수준2() { }
function 중수준2() { 저수준3(); }
function 저수준3() { }
```