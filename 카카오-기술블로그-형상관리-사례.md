## 카카오 i 오픈빌더 서비스의 프런트 엔드 형상관리 사례
> 이 글을 읽기 위해 <a href="https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88" target="_blank">Git의 기초</a>와 <a href="https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98" target="_blank">Git 브랜치</a> 사전지식이 필요합니다.

### 글의 목적
작년 12월 3일부터 카카오 i 오픈빌더의 프런트 서비스를 운영하며 많은 기능이 추가되었습니다. 사용자들에게 유용한 기능을 빠른 시간에 제공하기 위해서 코딩역량만큼 도움이 됐던 역량은 형상관리 역량입니다. 서비스를 운영하면 계획했던 일정 사이에 추가 기능이 필요할 때가 있고, 기능에 문제가 발생해 핫픽스 할 때가 있습니다. 유용한 기능들을 제공하기 위해서 형상관리에 대한 다양한 난관을 부딪쳤습니다.

서비스는 한 달 기간마다 신규 기능을 업데이트하고 있습니다. 지속해서 유용한 기능을 제공하기 위해서는 안정된 기능개발과 개발된 코드를 관리하는 게 중요했습니다. 어떻게 기능 개발 이력을 관리하고 기능 개발을 하는지 사례를 소개합니다. 그리고 예외 상황일 때 어떻게 대응을 했는지 사례를 소개합니다.

### 목차
- [작은 단위로 작업 이력 관리](#작은-단위로-작업-이력-관리)
- [작은 단위로 브랜치 관리](#작은-단위로-브랜치-관리)
- [예외 상황일 때 대응 사례](#예외-상황일-때-대응-사례)
- [맺음말](#맺음말)

### 작은 단위로 작업 이력 관리
작은 단위의 기능을 작업을 하고 해당 이력을 남기는 것이 빠른 작업에 도움이 됐습니다. 작은 단위의 기능으로 작업하면 해당 기능이 제대로 동작하게 만들기 쉽고 조합하여 큰 단위의 기능으로 만들기 쉽습니다. 작은 단위의 기능이 모여서 큰 단위로 사용자들에게 제공됩니다. 어떻게 작은 단위로 작업을 할 수 있는 지 그리고 작은 단위로 작업하지 않을 때 어떤 문제가 발생하는 지 사례를 소개합니다.

#### 작은 단위로 작업 이력을 남기는 방법
제가 제시하는 작은 단위의 기능은 사용자 스토리입니다. 사용자 스토리란 기획서를 기준으로 사용자 관점에서 작성한 글입니다. 사용자 스토리를 작성할 때는 하나의 기능만 작성하고 **~하면 ~한다** 방식으로 작성됩니다.

##### 사용자 스토리 예시
```
- 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
- 댓글 버튼을 클릭하면, 댓글을 볼 수 있다.
- 공유하기 버튼을 클릭하면, 공유하기 팝업이 열린다.
```

이렇게 잘게 나뉜 사용자 스토리는 경험상 코드 수정량도 많지 않았습니다. 작성된 각 사용자 스토리가 하나의 커밋 단위가 되고, 커밋 메시지가 됩니다. 사용자 스토리로 이력을 남길 때 장점은 두 가지가 있습니다. 첫 번째는 작업이력을 확인했을 때 각 이력에 어떤 작업을 했는 지 확인하기 쉽습니다. 두 번째는 이력확인이 쉬우므로 기능에 문제가 발생했을 때 특정 이력을 되돌리거나 특정 이력만 가져오고 싶을 때 쉽습니다.

#### 작은 단위로 하지 않을 때 사례
작업을 파악하기 힘든 이력을 종종 보기도 합니다. 의미를 파악하기 힘든 커밋은 커밋을 되돌리거나 특정 커밋만 가져오고 싶을 때 시간이 많이 들고 실수할 확률이 높았습니다. 경험상 대표적으로 두 가지 사례가 있었습니다. 

첫 번째는 한 작업의 커밋에 다른 작업을 포함해서 커밋하는 것입니다. 코드의 양이 많지 않아 작업이 다른 커밋에 포함해서 커밋을 하는 경우입니다. 이 경우는 해당 커밋을 삭제하고 싶을 때 다른 기능에 영향을 미칩니다.

두 번째는 사용자 스토리를 무수히 많이 작업한 뒤 커밋을 하나만 하는 것입니다. 한 이력에 커밋을 했을 때 특정 기능의 이력을 찾기 힘듭니다. 특정 코드의 작업 이력을 통해 "왜 이렇게 작성했는지"가 필요할 때가 있습니다. 그때 작업 이력을 보기도 하는데 한 이력에 커밋이 있으면 코드와 작업 이력으로 분석이 안 되었던 경험이 있습니다.

### 작은 단위로 브랜치 관리
작은 단위의 기능이 모여 큰 기능이 됩니다. 큰 기능의 관리는 브랜치로 하고 있습니다. 브랜치 관리도 추가할 기능을 작게 나눌 수록 개발할 때 쉬웠습니다. 경험상 기능의 볼륨이 클 때와 많은 기능을 혼자 개발할 때가 빈번하게 발생하여 두 가지에 대한 사례를 설명합니다.

#### 기능의 볼륨이 클 때 사례
특정 기능을 개발하는 데 파일 수정 사항이 많을 때 그리고 기능의 요구사항이 연관된 페이지가 많아 다수의 페이지에서 설정과 사용하는 동작일 때는 코드 수정사항이 많을 것으로 예상되는 상황입니다. 이런 상황일 때 하나의 브랜치에서 개발하면 코드리뷰 또는 병합할 때 힘들어집니다. 이런 상황에도 기능을 쪼개서 feature 브랜치를 다수 만드는 것을 권하고 싶습니다.

기능을 쪼개는 단위는 페이지나 부문으로 나누면 경험상 대부분 해결됐습니다. 이렇게 브랜치를 나누면 해당 기능 개발에 집중할 수 있고, 코드리뷰 시 코드분량의 따른 부담을 줄일 수 있습니다.

##### 그림1. 작은 기능을 나눠만든 feature 브랜치 예시
![]({{ '/assets/img/git-scm-experience/1.png' | prepend: site.baseurl }})

#### 많은 기능을 혼자 개발 할 때 사례
이 상황은 확실히 분리 가능한 기능들을 혼자서 개발해야 할 때입니다. 혼자 작업을 하더라도 feature 브랜치를 나누는 것이 업무의 효율을 높일 수 있습니다. 특정 기능이 제거되거나 다수의 기능 중 일부만 배포해야 되는 상황이 존재합니다.

브랜치가 하나일 경우 특정 기능을 제거하기 위한 많은 시간과 위험성을 가지게 됩니다. 다수의 브랜치로 작업을 하게 되면 병합 전에는 유연하게 대응 가능하므로 브랜치를 나눠 작업하는 것을 권하고 싶습니다.

##### 그림2. 기능을 나눠만든 feature 브랜치 예시
![]({{ '/assets/img/git-scm-experience/2.png' | prepend: site.baseurl }})

### 예외 상황일 때 대응 사례
예외 상황일 때 발생하는 형상관리 이슈는 feature 브랜치를 작업할 때 빈번하게 발생합니다. feature 브랜치 전략에 대한 경험적인 내용과 급히 기능 추가에 대한 경험을 작성한 부분입니다.

#### 병합 중에 충돌 발생한 사례
충돌은 feature 브랜치를 develop 브랜치에 병합을 할 때 발생할 확률이 높습니다. 충돌이 발생하면 develop 브랜치를 feature 브랜치에 병합합니다.
병합 시에는 발생한 충돌 사항들 중 동료와 연관있는 기능이라면 꼭 페어 체크를 해야 합니다.

##### 그림3. develop 브랜치를 feature 브랜치에 병합 예시
![]({{ '/assets/img/git-scm-experience/9.png' | prepend: site.baseurl }})<br>

충돌을 수정완료 한 뒤에는 다시 feature 브랜치를 develop 브랜치에 병합하면 완료됩니다.

##### 그림4. feature 브랜치를 develop 브랜치에 병합 예시
![]({{ '/assets/img/git-scm-experience/10.png' | prepend: site.baseurl }})

#### Pull Request 중인 브랜치에 작업한 사례
이 상황은 실수로 PR(Pull Request) 중인 브랜치로 작업을 하는 경우입니다. 이때 PR 중인 브랜치를 기준으로 브랜치를 생성하는 선택을 하면 안 됩니다. PR이 완료되어 브랜치를 삭제하면 연관된 브랜치도 삭제되기 때문입니다.

이 경우를 해결하기 위해서는 먼저 feature 브랜치를 develop 브랜치로부터 만든다. 그리고 생성한 feature 브랜치에 필요한 내용만 `cherry-pick`하여 가져가면 해결됩니다.

##### 그림5. cherry-pick 예시
![]({{ '/assets/img/git-scm-experience/11.png' | prepend: site.baseurl }})

#### 예정된 배포 일정 앞에 기능 배포한 사례
이 상황은 신규 기능 개발은 급하게 필요하지만, develop에 반영되어있던 기능들이 production에 배포하면 안 되는 사항이 있을 때입니다.

이 상황은 hotfix 전략으로 해결할 수 있습니다. 먼저 `hotfix/YYYYMMDD`로 hotfix+develop 역할의 핫픽스 개발 브랜치를 생성합니다. hotfix 처럼 개발완료 시 master/develop에 병합되고, develop 처럼 feature를 만들어 병합할 수 있는 역할의 브랜치입니다. 

##### 그림6. hotfix+develop 역할 브랜치 만들기 예시
![]({{ '/assets/img/git-scm-experience/12.png' | prepend: site.baseurl }})<br>

그리고 `hotfix/YYYYMMDD`를 기준으로 기능별로 브랜치를 만들어서 작업합니다. 해당 브랜치도 핫픽스의 의미를 내포하여 hotfix라는 접두사를 붙여 작명을 합니다.

##### 그림7. hotfix 브랜치 만들기 예시
![]({{ '/assets/img/git-scm-experience/13.png' | prepend: site.baseurl }})<br>

각 기능의 PR은 `hotfix/YYYYMMDD`에 진행을 합니다. 개발 완료 후 내부 테스트가 필요하면 Sandbox에 배포 시 `hotfix/YYYYMMDD`로 배포를 합니다. 

##### 그림8. hotfix 브랜치를 hotfix/YYYYMMDD 브랜치에 병합 예시
![]({{ '/assets/img/git-scm-experience/14.png' | prepend: site.baseurl }})<br>

테스트 완료 후 master/develop에 머지를 진행합니다. production 배포는 기존 프로세스와 같이 master로 진행합니다. 이렇게 되면 깃플로우 정책을 해치지 않고 작업이 가능합니다.

##### 그림9. hotfix/YYYYMMDD를 master와 develop 브랜치에 병합 예시
![]({{ '/assets/img/git-scm-experience/15.png' | prepend: site.baseurl }})

##### 고민이 되었던 부분
이 솔루션을 알기 전까지는 배포하는 부분에서 고민했습니다. develop/master를 통해서만 배포를 해야 한다는 생각을 가졌는데,
이러한 상황에서는 유연하게 hotfix와 master로 배포하는 것으로 정리하면 유연하게 대응 가능하다고 판단했습니다.

### 맺음말
제한된 일정에 요구사항을 개발하는 것은 힘든 작업입니다. 힘든 작업 후에 형상관리에서 문제가 발생하면 시간과 에너지를 많이 소비하게 됩니다. 되도록 작은 단위로 커밋을 하고 명확한 전략을 따르는 것을 권하고 싶습니다.