## 프런트 개발자 피터의 형상관리 사례
> 이 글을 읽기 위해 [Git의 기초](https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88)와 [Git 브랜치](https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98) 사전지식이 필요합니다.

### 들어가며
작년 12월 3일부터 봇 플랫폼인 [카카오 i 오픈빌더](https://i.kakao.com)를 개발하며 많은 기능을 추가했습니다. 유용한 기능을 적당한 시기에 제공하기 위해서 코딩역량만큼 도움이 됐던 역량은 형상관리 역량입니다. 서비스를 운영하며 계획했던 일정 사이에 추가 기능이 필요할 때가 있고, 기능에 문제가 발생해 핫픽스 할 때가 있습니다. 유용한 기능들을 제공하기 위해서 이러한 난관을 부딪치기도 합니다.

서비스는 한 달 마다 기능을 업데이트하고 있습니다. 지속해서 유용한 기능을 제공하기 위해서는 안정된 기능개발과 개발된 코드를 관리하는 게 중요했습니다. 어떻게 기능 개발 이력을 관리하고 기능 개발을 하는지 사례를 소개합니다. 그리고 예외 상황일 때 어떻게 대응을 했는지 사례를 소개합니다.

### 목차
- [사용자 스토리로 작업 이력 관리](#사용자-스토리로-작업-이력-관리)
- [깃 플로우 기반으로 브랜치 관리](#깃-플로우-기반으로-브랜치-관리)
- [예외 상황일 때 대응 사례](#예외-상황일-때-대응-사례)

### 사용자 스토리로 작업 이력 관리
기능 개발 후 작업 이력을 남길 때 어떤 기능을 작업했는지 메시지를 남깁니다. 메시지를 작성할 때 단어 선택을 고민하거나 수정내용을 다시 확인하고 작성하기도 합니다. 또한, 수정하고자 한 기능 이외에 다른 기능도 수정할 때 많은 작업 이력을 메시지에 작성하기도 합니다.

메시지를 작성하는 것은 중요하면서 소모적입니다. 그리고 수정범위를 정하지 않으면 다른 기능도 수정하게 됩니다. 이렇게 작업 이력의 메시지 작성과 작업 이력의 수정범위를 규칙을 정할 필요성이 생겨 어떻게 효율적으로 작성할 수 있을지 고민을 하게 되었습니다.

#### 작업 이력은 사용자 스토리로!
작업 이력을 남길 때는 사용자 스토리로 하는 게 효율적이었습니다. 사용자 스토리란 기획서를 기준으로 사용자 관점에서 작성한 글입니다. 사용자 스토리는 일정산정 시 첫 단계로 작성하고 있었습니다. 사용자 스토리를 기준으로 기능을 수정하고 작업 이력의 메시지로 활용할 수 있습니다.

##### 사용자 스토리 예시
```
- 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
- 댓글 버튼을 클릭하면, 댓글을 볼 수 있다.
- 공유하기 버튼을 클릭하면, 공유하기 팝업이 열린다.
```

사용자 스토리는 경험상 코드 수정량도 많지 않았습니다. 각 사용자 스토리가 하나의 커밋 단위가 되고, 커밋 메시지가 됩니다. 사용자 스토리로 이력을 남길 때 장점은 두 가지가 있습니다. 첫 번째는 작업 이력을 확인했을 때 각 이력에 어떤 작업을 했는지 확인하기 쉽습니다. 두 번째는 이력확인이 쉬우므로 기능에 문제가 발생했을 때 특정 이력을 되돌리거나 특정 이력만 가져오기 쉽습니다.

#### 작업 이력의 의미를 파악하기 힘든 사례
코드 이력을 확인할 때 작업과 코드 내용이 일치하지 않아 의미를 파악하기 힘들 때가 있습니다. 의미를 파악하기 힘든 이력은 이력을 되돌리거나 특정 이력만 가져오고 싶을 때 시간이 많이 들고 실수할 확률이 높았습니다. 경험상 대표적으로 두 가지 사례가 있었습니다. 

첫 번째는 이력과 다른 기능 수정을 포함하는 것입니다. 커밋을 할 때 코드의 양이 많지 않다는 이유로 다른 작업을 포함해서 이력을 남기는 경우입니다. 이 경우는 해당 커밋을 삭제하고 싶을 때 다른 기능의 영향을 알기 쉽지 않습니다.

##### 첫 번째 사례의 작업 이력 예시
```
좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
```

##### 첫 번째 사례의 작업 이력에 따른 수정된 코드 예시
```
- 좋아요 버튼에 onClickLike 이벤트 추가
- onClickLike 호출 시 공감수가 1증가
- 공유하기 버튼이 클릭 안되는 이슈 해결
  => 이력으로 추측 할 수 없는 수정 사항
```

두 번째는 많은 작업을 한 뒤 이력을 하나에 모두 작성하는 것입니다. 기능을 개발하는 데 집중하여 각 작업에 대한 이력을 남기지 못할 때 발생하기도 합니다. 이 경우는 특정 코드의 작업 이력을 찾기 힘들게 합니다.

##### 두 번째 사례의 작업 이력 예시
```
타임라인 기능 수정
- 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
- 댓글 버튼을 클릭하면, 댓글을 볼 수 있다.
- 공유하기 버튼을 클릭하면, 공유하기 팝업이 열린다.
```

##### 두 번째 사례의 작업 이력에 따른 수정된 코드 예시
```
- 좋아요 버튼에 onClickLike 이벤트 추가
- 댓글 버튼에 onClickComment 이벤트 추가
- 공유하기 버튼에 onClickShare 이벤트 추가
- onClickLike 호출 시 공감수가 1증가
- onClickComment 호출 시 댓글 영역을 노출
- onClickShare 호출 시 공유하기 팝업을 노출
```

### 깃 플로우 기반으로 브랜치 관리
서비스를 운영할 때 협업자와 같은 저장소를 사용하게 됩니다. 이때 개발 · 배포 · 핫픽스 작업에 대한 브랜치 정책이 없으면 산발적으로 관리하게 됩니다. 제가 참여했던 프로젝트에서는 관리를 쉽게 하는 방법으로 깃 플로우를 사용했습니다. 깃 플로우와 브랜치 작명에 대한 경험을 소개하겠습니다.

#### Feature 브랜치에서 기능 개발
기능을 개발할 때는 feature 브랜치에서 작업합니다. feature 브랜치를 develop 브랜치로부터 만들고 어떤 작업인지 네이밍을 통해 명시합니다.

##### 그림1. feature 브랜치 만들기 예시
![3](https://user-images.githubusercontent.com/17817719/59970763-30aa7580-95a9-11e9-8a89-53d39c5c3126.png)<br>

네이밍은 `feature/[기능명]`, `feature/[이슈 아이디]` 규칙을 가졌습니다. 기능명을 지을 때 동사 · 명사 사용 제한은 두지 않고 있습니다. 이슈 아이디는 업무관리 시스템에서 발급되는 티켓명 또는 이슈 아이디를 사용합니다.

##### feature 브랜치 작명 예시
```
[결제페이지] => feature/payment-page
[게시판 글쓰기] => feature/write-board
[버튼 미동작 이슈] => feature/fix-non-operation-button
[이슈 아이디 예] => feature/BOT-1234
```
개발이 완료되면 feature 브랜치에서 develop 브랜치로 머지합니다.

##### 그림2. feature 브랜치 머지 예시
![4](https://user-images.githubusercontent.com/17817719/59970764-30aa7580-95a9-11e9-99ef-b41a9e6dca70.png)

#### Release 브랜치에서 배포 개발
배포 시기에는 release 브랜치에서 작업합니다. release 브랜치는 develop 브랜치로부터 만들고 언제 또는 무엇에 대한 배포인지 네이밍에 명시합니다.

##### 그림3. release 브랜치 만들기 예시
![5](https://user-images.githubusercontent.com/17817719/59970765-31430c00-95a9-11e9-8662-1c473090ebc6.png)<br>

release 브랜치는 feature 브랜치와 다르게 확실한 작명 정책이 필요합니다. 개발 기간에 수정된 내용을 배포하는 것이므로 `release/YYYYMMDD`, `release/[version]`, `release/[스프린트명]`을 사용했습니다.

release 브랜치에서 QA 완료 후 배포를 하게 됩니다. 완료 후에 release 브랜치는 master와 develop 브랜치에 머지되며 배포 태그를 생성합니다. 그리고 master 브랜치를 기준으로 서비스 배포를 진행하면 배포가 완료됩니다.

##### 그림4. release 브랜치 머지 예시
![6](https://user-images.githubusercontent.com/17817719/59970766-31430c00-95a9-11e9-9f24-8088943d702d.png)<br>

#### Hotfix 브랜치에서 긴급 수정
핫픽스는 배포한 소프트웨어가 비즈니스적으로 문제가 발생했을 때 즉각 대응하는 방안입니다. 큰 이슈가 아닌 이상 핫픽스를 추천하지 않습니다. 마이너한 버그는 다음 배포 시기에 포함하는 게 안정적인 서비스 운영에 도움이 됩니다.

hotfix 브랜치는 master 브랜치로부터 만듭니다. 네이밍은 `hotfix/fix-[기능명]`으로 작명했습니다.

##### 그림5. hotfix 브랜치 만들기 예시
![7](https://user-images.githubusercontent.com/17817719/59970767-31430c00-95a9-11e9-8f28-baa88a83f908.png)<br>

기능 수정이 완료되면 hotfix 브랜치는 develop과 master 브랜치에 머지되고 핫픽스 태그를 생성합니다.

##### 그림6. hotfix 브랜치 머지 예시
![8](https://user-images.githubusercontent.com/17817719/59970768-31430c00-95a9-11e9-9fd2-2083b618b3c4.png)

### 예외 상황일 때 대응 사례
예외 상황일 때 발생하는 형상관리 이슈는 feature 브랜치를 작업할 때 빈번하게 발생했습니다. feature 브랜치 전략에 대한 경험과 깃 플로우의 hotfix와 develop 브랜치를 변형하여 대응한 사례를 소개합니다.

#### 머지 중에 컨플릭트 발생한 사례
컨플릭트는 feature 브랜치를 develop 브랜치에 머지을 할 때 발생할 확률이 높았습니다. 컨플릭트가 발생하면 develop 브랜치를 feature 브랜치에 머지합니다. 머지 시에는 발생한 컨플릭트 사항 중 동료와 연관있는 기능이라면 꼭 동료와 함께 확인이 필요합니다.

##### 그림7. develop 브랜치를 feature 브랜치에 머지 예시
![9](https://user-images.githubusercontent.com/17817719/59970769-31dba280-95a9-11e9-8814-0bed4545ab29.png)<br>

컨플릭트를 수정 한 뒤에는 다시 feature 브랜치를 develop 브랜치에 머지하면 완료됩니다.

##### 그림8. feature 브랜치를 develop 브랜치에 머지 예시
![10](https://user-images.githubusercontent.com/17817719/59970770-31dba280-95a9-11e9-8ee1-ca4437b4a6a1.png)

#### Pull Request 중인 브랜치에 작업한 사례
이 상황은 실수로 PR(Pull Request) 중인 브랜치로 작업을 하는 경우입니다. 이때 PR 중인 브랜치를 기준으로 브랜치를 생성하면 안됩니다. PR이 완료되어 브랜치를 삭제하면 연관된 브랜치도 삭제되기 때문입니다.

이 경우를 해결하기 위해서는 먼저 feature 브랜치를 develop 브랜치로부터 만듭니다. 그리고 생성한 feature 브랜치에 필요한 내용만 `cherry-pick`하여 가져가면 해결됩니다. `cherry-pick`은 다른 브랜치에 반영된 일부 커밋을 현재 브랜치에 반영하는 기능입니다.

##### 그림9. cherry-pick 예시
![11](https://user-images.githubusercontent.com/17817719/59970771-31dba280-95a9-11e9-9a2b-508c0d1c61c5.png)

#### 예정된 배포 일정 앞에 기능 배포한 사례
이 상황은 급하게 신규 기능 개발이 필요하지만, develop에 반영되어있던 기능들이 실 서비스에 배포하면 안 되는 사항이 있을 때입니다.

이 상황은 hotfix 전략으로 해결할 수 있습니다. 먼저 `hotfix/YYYYMMDD` 네이밍으로 브랜치를 만듭니다. 해당 브랜치는 hotfix+develop 역할의 핫픽스 개발 브랜치입니다. 개발완료 시 hotfix 처럼 master와 develop에 머지하고, develop처럼 feature를 만들어 머지할 수 있는 역할의 브랜치입니다. 

##### 그림10. hotfix+develop 역할 브랜치 만들기 예시
![12](https://user-images.githubusercontent.com/17817719/59970772-31dba280-95a9-11e9-88f5-112865e592a6.png)<br>

그리고 `hotfix/YYYYMMDD`를 기준으로 기능별로 브랜치를 만들어서 작업합니다. 해당 브랜치도 핫픽스의 의미를 내포하여 hotfix라는 접두사를 붙여 작명합니다.

##### 그림11. hotfix 브랜치 만들기 예시
![13](https://user-images.githubusercontent.com/17817719/59970773-32743900-95a9-11e9-86c7-c17466f6a623.png)<br>

각 기능의 PR은 `hotfix/YYYYMMDD`에 진행을 합니다. 개발 완료 후 내부 테스트가 필요하면 샌드박스에 배포 시 `hotfix/YYYYMMDD`로 배포를 합니다. 

##### 그림12. hotfix 브랜치를 hotfix/YYYYMMDD 브랜치에 머지 예시
![14](https://user-images.githubusercontent.com/17817719/59970774-32743900-95a9-11e9-839d-0825e9d5ca5e.png)<br>

테스트 완료 후 master와 develop에 머지를 진행합니다. 실 서비스 배포는 기존 프로세스와 같이 master로 진행합니다. 이렇게 되면 깃플로우 정책을 해치지 않고 작업이 가능합니다.

##### 그림13. hotfix/YYYYMMDD를 master와 develop 브랜치에 머지 예시
![15](https://user-images.githubusercontent.com/17817719/59970775-32743900-95a9-11e9-9d3e-6a243e6c4bd8.png)

##### 고민이 되었던 부분
이 솔루션을 알기 전까지는 배포하는 부분에서 고민했습니다. develop/master를 통해서만 배포를 해야 한다는 생각을 가졌는데,
이러한 상황에서는 유연하게 hotfix와 master로 배포하는 것으로 정리하면 유연하게 대응 가능하다고 판단했습니다.

### 끝
제한된 일정에 요구사항을 개발하는 것은 힘든 작업입니다. 힘든 작업 후에 형상관리에서 문제가 발생하면 시간과 에너지를 많이 소비하게 됩니다. 되도록 작은 단위로 커밋을 하고 명확한 전략을 따르는 것이 효율적으로 시간을 사용할 수 있었습니다. 기준이 필요하면 사용자 스토리와 깃 플로우를 기준으로 작업하는 것을 권하고 싶습니다.