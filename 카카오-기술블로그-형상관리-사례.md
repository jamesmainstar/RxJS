## 카카오 i 오픈빌더(프런트) 형상관리 사례
> 이 글을 읽기 위해 [Git의 기초](https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88)와 [Git 브랜치](https://git-scm.com/book/ko/v1/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98) 사전지식이 필요합니다.

### 들어가며
작년 12월 3일부터 [카카오 i 오픈빌더](https://i.kakao.com)의 프런트 영역을 담당했습니다. 업무 진행 시 형상관리 역량은 제한된 일정에 기능을 개발할 때 코딩역량만큼 중요시되는 역량입니다. 서비스를 운영하며 형상관리에 관한 난관에 부딪히기도 합니다. 예를 들어 계획했던 일정 사이에 기능 추가가 필요할 때가 있고, 기능에 문제가 발생해 긴급 수정할 때가 있습니다.

지속해서 서비스에 유용한 기능을 제공하기 위해서는 안정된 기능개발과 개발된 코드를 관리하는 게 중요했습니다. 어떻게 기능 개발 이력을 관리하고 기능 개발을 하는지 사례를 소개합니다. 그리고 예외 상황일 때 어떻게 대응을 했는지 사례를 소개합니다.

### 사용자 스토리를 활용한 작업 이력 관리
이 글에서 이야기하는 작업 이력은 `commit` 단위입니다. 그리고 앞으로 이야기할 메시지는 `commit` 시 작성하는 메시지를 의미합니다.

개발 후 어떤 기능을 개발했는지 메시지를 남깁니다. 메시지를 통해 작업 이력을 확인함으로 메시지를 남기는 과정은 중요했습니다. 하지만 메시지를 남기는 과정에 소모적인 시간이 많았습니다. 메시지 작성 시 단어 선택을 고민하거나 수정사항을 다시 확인하고 작성하기도 했습니다. 개발과 메시지를 고민하는 과정은 일과 중에 여러 번 발생하기 때문에 소모적인 시간이 많았습니다.

개발할 때 수정 범위를 정하는 것은 중요했습니다. 그 이유는 수정 범위를 정하지 않아서 다른 기능을 수정할 여지가 생기는 경우가 나타나기 때문입니다. 그리고 수정한 기능이 작은 기능이라고 판단하고 수정을 하기도 했습니다. 결국, 수정 범위 외에 기능을 수정하여 많은 메시지를 남기게 됐습니다.

이렇게 메시지를 고민하는 소모적인 과정 개선과 수정 범위를 명확히 할 필요성이 생겼습니다. 이 과정을 어떻게 효율적으로 해결할지 고민하게 되었습니다. 고민과 실험 끝에 결정한 방법은 사용자 스토리로 메시지를 작성하고 수정 범위를 정하는 것입니다.

이제부터 자세히 알아보도록 하겠습니다.

#### 작업 이력은 사용자 스토리로!
사용자 스토리는 사용자 관점에서 기능 동작을 작성한 글입니다. 그 글에는 단 한 가지의 동작을 작성합니다. 사용자 스토리의 작성 시기는 일정 산정 시 기획서를 기준으로 작성하고 있습니다. 그래서 개발 시 사용자 스토리는 준비된 상태입니다.

이렇게 작성된 사용자 스토리는 한 가지의 동작을 의미하므로 수정 범위가 명확합니다. 그리고 수정 내용은 사용자 스토리로 설명이 됩니다. 즉, 사용자 스토리로 수정 범위 제한과 메시지를 작성할 수 있습니다.

##### 사용자 스토리 예시
```
- 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
- 댓글 버튼을 클릭하면, 댓글을 볼 수 있다.
- 공유하기 버튼을 클릭하면, 공유하기 팝업이 열린다.
```
사용자 스토리로 메시지를 남기면 두 가지 장점이 있습니다. 첫 번째는 작업 이력을 확인할 때 각 작업 이력에 어떤 수정을 했는지 파악하기 쉽습니다. 두 번째는 작업 이력의 확인이 쉬우므로 기능에 문제가 발생했을 시 특정 작업 이력을 되돌리거나 특정 작업 이력만 가져오기 쉽습니다.

#### 작업 이력의 의미를 파악하기 힘든 사례
작업 이력을 확인할 때 메시지와 수정 내용이 일치하지 않아 의미를 파악하기 힘들 때가 있습니다. 의미를 파악하기 힘든 작업 이력은 작업 이력을 되돌리거나 특정 작업 이력만 가져오고 싶을 때 시간이 많이 소요되고 실수할 확률이 높았습니다.

대표적으로 두 가지 사례가 있습니다.

첫 번째는 메시지와 일치하지 않은 수정 내용을 포함하는 것입니다. 수정한 코드의 양이 많지 않다는 이유로 다른 수정 내용을 포함해서 작업 이력을 남기는 경우입니다. 이 경우는 작업 이력을 삭제하고 싶을 때 해당 작업 이력에 다른 수정 내용이 포함되어 있는지 알아보기 쉽지 않습니다.

##### 첫 번째 사례의 예
여기서 **메시지**와 **수정 내용 중 3번**이 일치하지 않습니다. 즉, 3번은 메시지로 추측할 수 없는 수정 내용입니다.
```
메시지: 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
수정 내용:
1. 좋아요 버튼에 onClickLike 이벤트 추가
2. onClickLike 호출 시 공감수가 1증가
3. 공유하기 버튼이 클릭 안 되는 이슈 해결
```

두 번째는 하나의 작업 이력에 많은 수정 내용과 메시지를 작성하는 것입니다. 개발에 집중하여 각 수정 내용에 대한 작업 이력을 남기지 못할 때 발생하기도 합니다. 이 경우는 특정 코드의 작업 이력을 찾기 어렵습니다.

##### 두 번째 사례의 예
```
메시지:
- 타임라인 기능 수정
  - 좋아요 버튼을 클릭하면, 공감수가 1개 증가한다.
  - 댓글 버튼을 클릭하면, 댓글을 볼 수 있다.
  - 공유하기 버튼을 클릭하면, 공유하기 팝업이 열린다.
수정 내용:
- 좋아요 버튼에 onClickLike 이벤트 추가
- 댓글 버튼에 onClickComment 이벤트 추가
- 공유하기 버튼에 onClickShare 이벤트 추가
- onClickLike 호출 시 공감수가 1증가
- onClickComment 호출 시 댓글 영역을 노출
- onClickShare 호출 시 공유하기 팝업을 노출
```

### 브랜치 전략을 벗어나지 않는 예외 상황 대응
서비스를 운영할 때 협업자와 같은 저장소를 사용하게 됩니다. 저장소를 사용할 때 개발 · 배포 · 핫픽스 작업에 대한 브랜치 정책이 없으면 산발적으로 관리하게 됩니다. 제가 참여했던 프로젝트에서는 관리를 쉽게 하는 방법으로 Git-flow를 사용했습니다.

Git-flow는 하나의 형상관리 솔루션입니다. Git-flow는 Merge를 기반으로 개발 · 배포 · 핫픽스에 대한 방법론을 제시합니다. 간단하게 Git-Flow의 브랜치 전략을 요약하면 아래와 같습니다. 자세한 내용은 [git-flow cheatsheet](https://danielkummer.github.io/git-flow-cheatsheet/index.ko_KR.html)을 참고 바랍니다.

```
- master: 배포 브랜치
- develop: 배포할 신규 기능을 관리하는 브랜치
- feature: 기능 개발할 때 사용하는 브랜치
- release: 배포 시기에 작업하는 브랜치
- hotfix: 배포한 소프트웨어를 즉각 대응할 때 작업하는 브랜치
```

이 글에서는 Git-flow 기반의 브랜치를 사용한 사례를 소개합니다. 예외 상황일 때 발생하는 형상관리 이슈는 feature 브랜치를 작업할 때 빈번하게 발생했습니다. feature 브랜치 전략에 대한 경험과 Git-flow의 hotfix와 develop 브랜치를 변형하여 대응한 사례를 소개하겠습니다.

#### Merge 중에 Conflict가 발생한 사례
Conflict는 feature 브랜치를 develop 브랜치에 Merge 할 때 발생할 확률이 높았습니다. Conflict가 발생하면 develop 브랜치를 feature 브랜치에 Merge 합니다. Merge 시에 발생한 Conflict가 동료의 작업과 연관 있는 기능이라면 꼭 동료와 함께 확인해야 합니다.

##### 그림1. develop 브랜치를 feature 브랜치에 Merge 예시
![9](https://user-images.githubusercontent.com/17817719/59970769-31dba280-95a9-11e9-8814-0bed4545ab29.png)

Conflict를 수정한 뒤에는 다시 feature 브랜치를 develop 브랜치에 Merge 하면 완료됩니다.

##### 그림2. feature 브랜치를 develop 브랜치에 Merge 예시
![10](https://user-images.githubusercontent.com/17817719/59970770-31dba280-95a9-11e9-8ee1-ca4437b4a6a1.png)

#### Pull Request 중인 브랜치에 작업한 사례
이 상황은 실수로 Pull Request 중인 브랜치로 작업을 하는 경우입니다. 이 때 Pull Request 중인 브랜치를 기준으로 새 브랜치를 생성하면 안 됩니다. Pull Request가 완료되어 브랜치를 삭제하면 연관된 브랜치도 삭제되기 때문입니다.

이 경우를 해결하기 위해서는 먼저 develop 브랜치에서부터 feature 브랜치를 생성합니다. 그리고 생성한 feature 브랜치에 필요한 내용만 `cherry-pick` 하여 가져가면 해결됩니다. `cherry-pick`은 다른 브랜치에 반영된 일부 커밋을 현재 브랜치에 가져오는 것을 말합니다.

##### 그림3. cherry-pick 예시
![11](https://user-images.githubusercontent.com/17817719/59970771-31dba280-95a9-11e9-9a2b-508c0d1c61c5.png)

#### 예정된 배포 일정 앞에 기능 배포한 사례
develop 브랜치에서 기능 개발 중인 전제 하에 위 사례에서는 두 가지 문제가 나타납니다. 첫 번째는 신규 기능 개발이 필요하고, 두 번째는 develop 브랜치에 반영된 기능들은 실 서비스에 배포하면 안 되는 것입니다.

이 상황은 hotfix 브랜치 전략으로 해결할 수 있습니다. 먼저 `hotfix/YYYYMMDD` 네이밍으로 브랜치를 만듭니다.

##### 그림4. hotfix+develop 역할 브랜치 만들기 예시
![12](https://user-images.githubusercontent.com/17817719/59970772-31dba280-95a9-11e9-88f5-112865e592a6.png)

그리고 `hotfix/YYYYMMDD`를 기준으로 기능별로 브랜치를 만들어서 작업합니다. 해당 브랜치도 핫픽스의 의미를 내포하여 hotfix라는 접두사를 붙여 작명합니다.

##### 그림5. hotfix 브랜치 만들기 예시
![13](https://user-images.githubusercontent.com/17817719/59970773-32743900-95a9-11e9-86c7-c17466f6a623.png)

각 기능의 Pull Request는 `hotfix/YYYYMMDD`에 진행을 합니다. 개발 완료 후 내부 테스트가 필요하면 hotfix/YYYYMMDD를 샌드박스에 배포합니다.

##### 그림6. hotfix 브랜치를 hotfix/YYYYMMDD 브랜치에 Merge 예시
![14](https://user-images.githubusercontent.com/17817719/59970774-32743900-95a9-11e9-839d-0825e9d5ca5e.png)

테스트 완료 후 master 브랜치와 develop 브랜치에 Merge합니다. 실 서비스 배포는 기존 프로세스와 같이 master 브랜치로 진행합니다. 이렇게 하면 Git-Flow 정책을 해치지 않고 작업이 가능합니다.

##### 그림7. hotfix/YYYYMMDD를 master와 develop 브랜치에 Merge 예시
![15](https://user-images.githubusercontent.com/17817719/59970775-32743900-95a9-11e9-9d3e-6a243e6c4bd8.png)

### 끝
제한된 일정에 요구 사항을 개발하는 것은 힘든 작업입니다. 힘든 작업 후에 형상관리에서 문제가 발생하면 시간과 에너지를 많이 소비하게 됩니다. 같은 고민을 하고 계시는 개발자분들께 조금이나마 도움이 되길 바라며 글을 마칩니다.
