### 목차
- [1. 전체: 프로그래밍 불변의 사실](#1-전체-프로그래밍-불변의-사실)
- [2. 원칙: 프로그래밍의 가이드라인](#2-원칙-프로그래밍의-가이드라인)
- [3. 사상: 프로그래밍의 이데올로기](#3-사상-프로그래밍의-이데올로기)
- [4. 관점: 프로그래머가 보는 시각](#4-관점-프로그래머가-보는-시각)
- [5. 습관: 프로그래머의 일상](#5-습관-프로그래머의-일상)

## 1. 전체: 프로그래밍 불변의 사실
#### 프로그래밍에 은제 탄환은 없다 (No Silver Bullet in programming)
서구 전설에 늑대인간이라는 무서운 마물이 나온다. 늑대인간은 평범한 일상을 영위하던 이들을 갑자기 무시무시한 괴물로 둔답시킨다.
늑대인간을 진정시킬 방법은 단 하나, 바로 은제 탄환을 쏘아 맞추는 것이다.

소프트웨어는 본질적으로 복잡성, 호환성, 변경 가능성, 비가시성(프로세스, 의사결정)이 4가지 성질 때문에 난해성을 갖고 있다.
이를 결과물로 하는 프로그래밍 작업 역시 난해해진다. 상황이 복잡하고 문제가 너무 다방면에 걸쳐 있기 때문에
모든 것을 해결하는 특효약은 존재할 수 없다.

#### 코드는 설계서다
기본 설계부터 상세 설계, 프로그래밍, 테스트, 디버깅까지 모든 과정이 설계이다.

#### 코드는 반드시 변경된다
소프트웨어는 본질적으로 복잡하며 완벽해질 수 없다. 배포된 후에 반드시 오류가 발생하고 문제를 해결해야 한다.
배포 후에 사용자로부터 요구사항이 늘어나 기능을 확장할 때도 있다. 사업 환경의 변화에 의해 요구사항이 변화해 간다.
즉, 변경에 강한 코드에 작성한다는 뜻이다. 그렇게 하려면 코드가 읽기 쉬워야 한다.

## 2. 원칙: 프로그래밍의 가이드라인
#### 2.1 KISS(Keep It Simple, Stupid / Keep It Short and Simple)
> 오컴의 면도날 : 어떤 사항을 설명하는 데 필요 이상으로 많은 전제를 가정해서는 안된다는 사고방식

코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둔다. 복잡한 코드는 일기 어렵고 수정하기 어려워진다.
프로그래밍 중에도 코드가 동작할 수 있는 가장 간단한 방법은 무엇인지 항상 질문을 던져야 한다.

복잡함으로 향하는 상황
1. 새롭게 배운 기술을 사용하고 싶다
2. 장래의 필요에 대비하고 싶다
3. 멋대로 요구사항을 추가한다

#### 2.2 DRY(Don't Repeat Yourself)
똑같은 코드가 여러 군데 있으면 모든 곳을 정확하게 수정하지 않는 이상 전체적으로 정합성을 보장할 수 없다. 코드 로직은 함수화, 모듈화하고, 데이터라면 이름을 붙여 상수를 정의한다.

디자인 패턴은 같은 문제에 관해 몇 번씩 반복해서 해결책을 생각하는 `사고의 중복`이 일어나지 않게 하는 기법이라고도 할 수 있다.

#### 2.3 YAGNI(You Aren't Going to Need it)
확장성을 고려해서 넣은 설계라도 예상은 대부분 빗나간다. 빗나간다는 것은 거기에 들인 시간이 쓸모없어진다는 뜻이다.
범용성보다는 단순성을 생각하자. 범용성이 가져다주는 재사용성이나 확작성도 좋지만, 그 보다는 우선 사용할 수 있는 데 가치를 두자.

#### 2.4 PIE(Program Intently and Expressively)
코드를 작성할 때는 의도를 명확하게 표현해야 한다. 소프트웨어의 동작을 파악하려면 코드를 읽는 수밖에 없다.
따라서 이해하기 쉬운 코드를 작성해서 코드로 의도를 표현해야 한다.

주석 없어도 읽을 수 있을 법한 이해하기 쉬운 코드를 작성하는 것이 이상적이다. 
다만 코드는 언제까지나 '무엇을 하는지'와 '어떻게 하는지'밖에 표현하지 못한다. 즉 '어째서 그것을 하는지'를 표현하려면 주석을 사용할 필요가 있다.

#### 2.5 SLAP(Single Level of Abstraction Principle)
코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다.
추상화 단계는 상하가 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다.
결과적으로 추상화 수준을 일치시킨 코드는 훌륭한 책과 같다. 최고 수준부터 중간 수준의 처리가 책의 '목차'가 되고 최저 수준의 처리가 책의 '본문 내용'이 된다.
```
function 고수준() { 중수준1(); 중수준2(); } // 수준1의 목차
function 중수준1() { 저수준1(); 저수준2(); } // 수준2의 목자-1
function 저수준1() { // } //
function 저수준2() { // }
function 중수준2() { 저수준3(); }
function 저수준3() { // }
```

#### 2.6 OCP(Open Closed Principle)
코드는 확장에 대해서 열려 있고 수정에 대해서 닫혀 있는 **2가지 속성**을 동시에 충족하도록 설계한다.
**확장**에 대해서 열려 있다는 말은 코드의 동작을 확장할 수 있나는 의미다.
**수정**에 대해서 닫쳐 있다는 말은 코드의 동작을 확장하더라도 그 밖의 코드는 전혀 영향을 받지 않는다는 의미다.
코드가 이런 2가지 속성을 동시에 충족한다면 기존 코드에 전혀 영향을 주지 않고도 기능을 확장할 수 있다.

#### 2.7 명명이 중요하다(Naming is important)
**적절한 이름을 붙일 수 있었다는 것**은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다. 반대로 어울리지 않는 이름을 붙여졌다는 것은
해당 요소가 달성해야 할 역할에 대해 프로그래머 자신이 충분히 이해하지 못했다는 뜻이다.

**이름**은 코드를 통해 프로그래머끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드상의 대화는 성립하지 않는다.

효과적인 이름 작성
- 이름이 효과와 목적을 설명하도록 한다.
- 이름은 발음 가능한 것으로 한다.
- 이름은 검색 가능하도록 붙인다.

루프백 확인

명명에는 '이름 가역성'이라는 개념이 있다. 이는 '이름이란 명명의 기반이 된 내용의 설명문을 복원할 수 잇어야 한다'는 명명 방침이다.
이 방침을 충족하려면 루프백 확인을 수행해야 한다. 내용의 설명문으로부터 이름을 떠올렸다면 이번에는 반대로 이름을 추측할 수 있는 설명문을 생각해 보는 것이다. 설명->이름->설명의 순으로 한 바퀴 돌아서 원래로 돌아왔을 때(루프백) 설명이 일치하면 좋은 이름이고, 일치하지 않으면 주의가 필요하다.

## 3. 사상: 프로그래밍의 이데올로기
#### 3.1 프로그래밍 이론
좋은 프로그래머는 시간이 걸리더라도 언어, 도구, 기술, 문제 영역 등 분야를 막론하고 제대로 이해하고 나서
작업에 착수하는 경향이 있다. 제대로 이유를 설명할 수 있을 때까지 끈질기게 이해하고 나서 코드를 확정하도록 하자.
#### 3.2 의사소통
소프트웨어 개발 비용의 대부분은 최초 개발된 이후에 발생한다. 즉, 유지보수에 드는 비용이다.
코드는 작성하는 시간보다 읽는 시간이 압도적으로 많다. 코드를 통해 원활하게 의사소통을 하려면 코드를 작성할 때 다른 사람의 입장에서 생각해야 한다.
#### 3.3 단순함
코드가 단순하다는 것은 코드에서 불필요한 복잡성이 제거된 상태를 가리킨다. 코드가 간결해지면 오류가 발생할 확률도 매우 낮아진다.
본질적인 부분을 눈에 잘 띄게 만들고, 그 이외의 불필요한 부분이 거기에 섞여들지 않도록 설계하자.
불필요한 복잡성을 제거하면 남은 본질이 더욱 두드러지고 이해가 쉬워지며 의사소통이 원활해진다.
#### 3.4 유연성
코드에서 유연성이란 코드 변경이 용이함을 뜻한다. 기존 코드가 새롭게 추가되는 코드를 반발이나 거부 반응 없이 받아들일 수 있는 점,
자신이 망가지지 않도록 완충을 해서 받아들일 수 있는 점, 양쪽 관점으로 유연이라는 표현이 사용되고 있다.
#### 3.9 선언형의 표현
선언형의 표현이란 코드의 의도를 전하고자 할 때 가능한 명령형보다는 선언형으로 표현하는 것을 뜻한다.
명령형 프로그래밍은 문제의 해법, 즉 자료구조와 알고리즘을 기술한다. 반면에 선언형 프로그래밍은 문제의 정의,
즉 해결해야 할 문제의 성질이나 이때 충족해야 할 제약을 기술한다.
#### 3.12 추상
추상이란 개념적으로 명확한 선 긋기를 수행하는 것이다. 선 긋기에 따라 어떤 모듈을 그 이외의 모듈로부터 명확하게 구별한다.
추상은 `사상`과 `일반화`라는 2가지 관점에서 정리도니다.

- **사상**은 복잡한 대상의 몇 가지 성질을 버리고 **특정한 성질에 주목**하는 것이다.
- **일반화**는 구체적인 대상으로부터 공통 성질을 추출해서 더욱 **범용적인 개념으로 정식화**하는 것이다.

## 4. 관점: 프로그래머가 보는 시각
### 4.1 응집도(Cohesion)
**응집도**란 모듈에 포함된 기능의 순수함을 나타내는 척도로, 모듈의 강도를 측정하는 단위다.
단계가 높을수록 순수하고 강하며 좋은 모듈이다. 모듈 내 요소 간 관계의 친밀함에 주목해서 판정한다.

#### 1단계: 암합적 강도
모듈 내 요소 간 특별한 관계가 인정되지 않는다. 예를 들면 모듈 내 중복된 명령의 패턴을 우연히 발견했다는 이유로 통합해서 하나의 모듈로 만든 경우다.
이때는 해당 모듈의 기능을 바르게 명명해서 정의할 수 없다.

#### 2단계: 논리적 강도
어떤 기능을 추상적으로 파악해서 모은 것이다. 예를 들면 모든 입출력 조작을 모아서 모듈화하거나 여러 가지 데이터를 편집하기 위한 모듈을 작성한 경우다.
하지만 관련된 기능을 하나의 모듈로 모은 것은 프로그래머의 사고를 집중시키는 장점이 있다.

#### 3단계: 시간적 강도
특정 시점에 연속해서 실행되는 여러 개의 기능을 하나의 모듈로 모은 것이다. 이때 기능 사이에 그다지 강한 관련성은 없다.
다만 특정 시점에 연속해서 실행될 뿐이다. 대표적인 사례가 초기 처리 모듈이다.

#### 4단계: 순서적 강도
문제를 처리하기 위해 관계된 여러 개의 기능은 순서대로 실행된다. 커다란 기능의 일부 순서를 하나의 모듈로 만들었다면 순서적 강도이다.

#### 5단계: 연락적 강도
연락적 강도 모듈은 기본적으로 순서적 강도의 특성을 갖는다. 순서적 강도와의 차이점은 모듈 내 기능 사이에서 데이터를 교환하거나 같은 데이터를 참조한다는 것이다.

#### 6단계: 정보적 강도
특정 자료구조를 다루는 여러 개의 기능을 하나의 모듈로 모은 것이다. 같은 자료구조(정보)는 가능한 한 특정 모듈에서만 접근하도록 하겠다는 발상이다.
논리적 강도 모듈 역시 정보 은닉의 특징을 갖고 있지만, 정보적 강도 모듈과의 차이점은 진입점의 개수다.
논리적 강도 모듈은 진입점을 하나만 가지며 실행할 기능은 파라미터에 의해 선택된다. 반면에 정보적 강도 모듈은 진입점을 여러 개 가지며
각 진입점은 단일한 고유 기능을 실행한다.

#### 7단계: 기능적 강도
모듈 내의 모든 명령이 하나의 역할(기능)을 실행하기 위해 서로 관련된 모듈로, 응집도가 가장 높은 모듈이다.
단일 기능을 수행하기 위해 모든 명령이 서로 관련된다.

### 4.2 결합도(Coupling)
**결합도**란 모듈끼리 갖는 관계의 밀접함을 나타내는 척도로, 어떤 결합의 굵기를 측정하는 단위다.
단계가 높을수록 관계가 약하고 느슨한 결합이며 좋은 모듈이라고 할 수 있다. 모듈 간에 데이터를 얼마나 교환하는지에 주목해서 판정한다.

#### 1단계: 내용 결합
한 모둘과 다른 모듈이 일부를 공유하는 모듈 결합 방식이다. 다른 모듈 내의 외부에 선언되지 않는 데이터를 직접 참조하거나 명령의 일부를 공유하는 경우가 여기에 해당한다.

#### 2단계: 공통 결합
공통 영역에 정의된 데이터를 몇 개 모듈이 공동으로 사용하는 모듈 결합 방식이다. 공통 영역에 정의된 데이터란 이른바 `전역 변수`를 말한다.

공통 결합은 결합도가 높고 단점이 많다.
- 인터페이스상에 나타나지 않으므로 코드 해독이 매우 어렵게 만든다.
- 관계가 없는 모듈에서 사용 가능하므로 코드의 안전성이 낮아진다.
- 여러 모듈과 이어져 있으므로 재사용성이 저해된다.

#### 3단계: 외부 결합
외부 결합이란 외부에 선언된 데이터를 공유하는 모듈 결합 방식이다. 외부에 선언된 데이터란 예를 들면 public으로 선언된 변수를 말한다.
공통 결합과 비숫한데, 필요한 데이터만 외부에서 선언하기 때문에 비교적 결합도가 약하다.

#### 4단계: 제어 결합
제어 결합이랑 호출하는 모듈 쪽에서 호출받는 모듈의 제어를 지시하는 데이터를 파라미터로 넘겨주는 모듈 결합 방식이다.
호출하는 쪽에서 호출받는 모듈의 논리를 알 필요가 있으므로 블랙박스처럼 다룰 수 없어 결합도가 강해진다.

#### 5단계: 스탬프 결합
스탬프 결합이란 공통 영역에 없는 자료구조(정보)를 2개의 모듈에서 교환하는 모듈 결합 방식이다.
자료구조의 교환은 파라미터를 매개로 수행한다. 불필요한 데이터까지 교환된다는 점이 결합도를 조금 강하게 만든다.

#### 6단계: 데이터 결합
데이터 결합이란 모듈 간의 인터페이스로 스칼라형 데이터 요소만들 파라미터로 교환하는 모듈 결합 방식이다.
상대 모듈을 블랙박스화할 수 있으므로 결합도는 가장 약하다. 스탬프 결합은 넘겨주는 자료구조(정보) 중에 일부 데이터만을 사용한다.
반대로 자료구조의 모든 데이터를 처리한다면 이는 데이터 결합이라고 간주해도 무방하다.

#### 멱등성과 안전성
모듈이나 함수가 갖는 성질 중에 멱등성과 안전성이라는 개념이 있다.

**멱등성**이란 '어떤 조작을 반복해서 수행해도 결과가 같은 것'을 의미하는 수학 용어다.
**안전성**이란 '조작 대상의 상태를 변화시키지 않는 것'을 의미한다.

## 5. 습관: 프로그래머의 일상
#### 프로그래머의 3대 미덕
**태만(자동화)**
전체의 노력을 줄이기 위해 수고를 아끼지 않는 기질이다. 나중에 모두가 편해지도록 지금 유용한 코드를 작성한다.
귀찮은 업무, 몇 번이나 되풀이되는 업무는 소프트웨어를 만들어 자동화한다.

**성급(서식화)**
컴퓨터가 충분히 효율적으로 동작하고 있지 않거나 의도대로 동작하지 않는다면 즉시 코드를 다시 작성한다.
작업의 품질과 작업에 드는 시간도 개선된다.

**오만(모듈화)**
높은 자존심을 갖고 남에게 내놓아도 부끄럽지 않는 코드를 작성한다. 책임감있게 전문가라는 의식을 갖고 작업에 착수한다.