### 1 코드는 이해하기 쉬워야 한다
코드는 다른 사람이 그것을 이해하는 데 들이는 시간을 최소화하는 방식으로 작성되어야 한다.

코드를 완전히 이해한다는 것은
1. 코드를 자유롭게 수정가능
2. 버그를 짚는 것을 가능
3. 수정된 내용이 작성한 다른 부분의 코드와 어떻게 상호작용하는지 알 수 있어야 함

을 의미한다.

## ONE 표면적 수준에서의 개선
### 2 이름에 정보 담기
### 3 오해할 수 없는 이름들
> 본인이 지은 이름을 `다른 사람들이 다른 의미로 해석할 수 있을까?`라는 질문을 던져보며 철저하게 확인해야 한다.

### 4 미학
### 5 주석에 담아야 하는 대상
### 6 명확하고 간결한 주석 달기
## TWO 루프와 논리를 단순화하기
### 7 읽기 쉽게 흐름제어 만들기
### 8 거대한 표현을 잘게 쪼개기
#### 예: 복잡한 논리와 씨름하기
주어진 양쪽 경계값이 other의 범위에 속하는지 확인하는 함수이다.
```js
const begin = 2;
const end = 4;
const overlapsWith = other => {
  return (begin >= other.begin && begin <= other.end) ||
    (end >= other.begin && end <= other.end);
};
```
생각해야 하거나 조건이 너무나 많으므로 버그가 발생할 확률이 매우 높다.
사실은 버그가 있다. 앞선 코드는 범위 `[0, 2)`가 `[2, 4)`와 겹친다고 말한다.

문제는 <= 혹은 <로 begin/end 값을 비교할 때 매우 신중해야 한다는 점이다. 이 버그를 수정하면 다음과 같다.
```js
const overlapsWith = other => {
  return (begin >= other.begin && begin < other.end) ||
    (end > other.begin && end <= other.end);
};
```
이제는 정확한가? 사실은 또 다른 버그가 있다. 이 코드는 begin/end가 other를 완전히 포함하는 경우를 무시한다.
이를 제대로 해결한 수정 코드는 다음과 같다.
```js
const overlapsWith = other => {
  return (begin >= other.begin && begin < other.end) ||
    (end > other.begin && end <= other.end) ||
    (begin <= other.begin && end >= other.end);
};
```
이 코드는 이제 걷잡을 수 없이 복잡해졌다. 다른 사람이 이 코드를 읽고 정확한지 판단할 수 있으리라고 기대할 수 는 없다.
그럼 이 거대한 표현을 어떻게 쪼갤 수 있을까?

#### 더 우아한 접근방법 발견하기
더 우아한 해결책을 찾으려면 창의력이 필요하다. 그럼 어떻게 하는가? 한 가지 해결책은 똑같은 문제를 `반대되는` 방법으로 해결할 수 있는지 확인하는 것이다.

여기서 overlapsWith의 반대는 `겹치지 않는 것`이다. 두 개의 범위가 서로 겹치지 않는 것을 확인하는 방법에는 두 가지 가능성만 존재하므로 훨씬 더 풀기 쉬운 문제로 다가온다.

1. 다른 범위가 이 범위 시작보다 전에 끝난다.
2. 다른 범위가 이 범위가 끝난 후에 시작된다.

이를 코드로 만드는 방법은 쉽다.
```js
const overlapsWith = other => {
  if (other.end <= begin) return false; // 시작보다 전에 끝난다.
  if (other.begin >= end) return false; // 끝난 후에 시작한다.
  return true;
};
```
코드의 각 줄은 전보다 훨씬 더 간단하다. 한 번의 비교만 표함할 뿐이다. 이렇게 하면 코드를 읽는 사람이 <= 연산자를 정확하게 사용했는 지 쉽게 확인할 수 있다.

### 9 변수와 가독성
## THREE 코드 재작성하기
### 10 상관없는 하위문제 추출하기
### 11 한 번에 하나씩
### 12 생각을 코드로 만들기
### 13 코드 분량 줄이기
## FOUR 선택된 주제들
### 14 테트스와 가독성
### 15 `분/시간 카운터`를 설계하고 구현하기