날짜를 다루는 방법이 프로젝트 코드에 너무 다양했다. 타임스탬브, YYYY-MM-DD, moment, Date등 다양한 형태로 존재한다. 하지만 타입을 다르게 사용할 필요없이 소비하는 쪽에서만 다르게 소비를 하면 된다. 그래서 강제성이 필요했다. 그리고 moment의 기능을 모두 활용하지 않아 낭비를 하고 있어서 새로운 커스텀 날짜 객체를 만들 것이다.

### 먼저 프로젝트에서 사용하는 기능을 식별한다.
- 다음 날짜, 이전 날짜 이동
- 년월일 비교
- 윤달 여부
- 마지막 달 가져오기
- 어제 날짜
- 날짜를 특정 포맷으로 변환하기
- 날짜범위 가져오기
이러한 기능들이 식별된다. 

### 그럼 이 기능을 토대로 인터페이스를 만든다.
```ts
class BeeDate extends Date {
  addDate(count: number): BeeDate {}
  subtractDate(count: number): BeeDate {}
  format(mapper: FormatMapper): string {}
  range(afterDate: BeeDate): BeeDate[] {}
  isSameDate(date: BeeDate): boolean {}
  isSameMonth(date: BeeDate): boolean {}
  isSameYear(date: BeeDate): boolean {}
  isLeapYear(): boolean {}
  getLastDay(): number {}
  getYesterday(): BeeDate {}
  clone(): BeeDate {}
  
  static create(value: number | string | BeeDate): BeeDate {}
  static createFromDate(
    year?: number,
    month?: number,
    date?: number,
    hours?: number,
    minutes?: number,
    seconds?: number,
    ms?: number
  ): BeeDate {}
}
```

### 실제 사용되는 곳에서 인터페이스만 변경해본다.
인터페이스를 설계해도 실제로 사용되는 곳에서 사용해보는 것이 좋다. 실제로 사용했을 때 원하는 방향으로 설계가 됬는 지 그리고 깔끔하게 설계가 되었는 지 알 수 있다. 그리고 인터페이스만 변경해보면서 중복적인 요소가 보이면서 필요한 기능을 또 식별할 수 있다.

### 테스트 코드를 작성하고 인터페이스 개발한다.
테스트 코드를 통해 해당 메소드들이 어떻게 동작해야 하는 지 스펙을 작성한다. 그리고 각 메소드들의 기능을 추가한다.

### 개발 완료 후 리펙토링
모든 코드가 개발되면 리펙토링을 한다. 테스트 코드를 통해 안전한 동작을 보장하기 때문에 리펙토링을 해도 안전성을 보장할 수 있다.