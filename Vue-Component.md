#### 컴포넌트를 통해 해결하고 싶은 문제
- HTML 엘리먼트의 확장, 재사용, 캡슐화
- 추론이 쉽고 유지 관리가 쉬운 의사소통 방법
  - 부모-자식 : `props`와 `event`를 통해 단방향 바인딩 사용
  - 비 부모-자식 : 이벤트 버스
- 컴포넌트에 제공된 속성과 컴포넌트에서 설정된 속성 처리
- 콘텐츠 배포 프로세스

#### 컴포넌트란 무엇인가
기본 HTML 엘리먼트를 `확장`하여 `재사용` 가능한 코드를 `캡슐화`하는 데 도움이 됩니다. Vue 인스턴스 이기 때문에 `모든 옵션 객체`와 `라이프 사이클 훅`을 사용할 수 있다.

#### `data`를 함수로 사용하는 이유
세 개의 컴포넌트 인스턴스가 모두 같은 `data` 객체를 공유하므로 하나의 카운터를 증가 시키면 모두 증가합니다.
그래서 `새로운 데이터 객체`를 반환하여 이 문제를 해결합니다.
```js
Vue.component('my-component', {
  template: '<span>{{ message }}</span>',
  data: {message: 'hello'}
})
```
```html
<div id="example-2">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
```

#### 컴포넌트 작성
컴포넌트는 부모-자식 관계에서 가장 일반적으로 함께 사용하기 위한 것이다. 컴포넌트 A는 자체 템플릿에서 컴포넌트 B를 사용할 수 있다.
그들은 필연적으로 서로 `의사소통`이 필요합니다. 부모는 자식에세 `데이터를 전달`해야 할 수도 있으며, 자식은 자신에게 일어난 일을 `부모에게 알릴 필요`가 있습니다.

그러나 부모와 자식이 명확하게 정의된 인터페이스를 통해 가능한한 `분리된 상태`로 유지하는 것도 매우 중요합니다.
이렇게하면 각 컴포넌트의 코드를 상대적으로 `격리` 할 수 있도록 작성하고 `추론`할 수 있으므로 `유지 관리가 쉽고` `잠재적으로 쉽게 재사용` 할 수 있습니다.

VueJs에서 부모-자식 컴포넌트 관계는 `props`는 아래로, `events` 위로 라고 요약할 수 있습니다. 부모는 `props`를 통해 자식에게 데이터를 전달하고 자식은 `events`를 통해 부모에게 메시지를 보냅니다.

#### Props
모든 컴포넌트 인스턴스에는 자체 `격리 범위`가 있습니다. 즉, 하위 컴포넌트의 템플릿에서 상위 데이터를 직접 참조 할 수 없으며
그렇게 해서는 안됩니다. 데이터를 `props`을 사용하여 하위 컴포넌트로 전달 될 수 있습니다.

`prop`는 상위 컴포넌트의 정보를 전달하기 위한 사용자 지정 특성입니다. 하위 컴포넌트는 `props` 옵션을 사용하여
수신 할 것으로 기대되는 `props`를 명시적으로 선언해야 합니다.

데이터가 상위에서 업데이트 될 때마다 하위 데이터로도 전달됩니다.

하위 속성과 상위 속성 사이의 `단방향 바인딩`을 형성합니다. 상위 속성이 업데이트되면 하위로 흐르게 되지만 그 반대는 안됩니다.
이렇게하면 하위 컴포넌트가 실수로 부모의 상태를 변경하여 앱의 `데이터 흐름을 추론하기 더 어렵게 만드는 것을 방지`할 수 있습니다.

#### 존재하는 속성 문제
대부분의 속성의 경우 컴포넌트에 제공된 값은 컴포넌트에서 설정된 값을 대체합니다. 예를 들어, `type="large"`가 전달되면
`type="data"`를 대체할 것이고 아마도 망가뜨릴 것입니다. `class`와 `style` 속성은 두 값이 합쳐져서 최종 값으로 만듭니다.

#### 자식 컴포넌트 정취
부모 컴포넌트는 자식 컴포넌트가 사용되는 템플릿에서 직접 `v-on`을 사용하여 자식 컴포넌트에서 보내진 이벤트를 청취할 수 있습니다.

#### 비 부모-자식간 통신
부모-자식이 아닌 두 컴포넌트가 서로 통신이 필요할 때 Vue 인스턴스를 중앙 이벤트 버스로 사용할 수 있습니다.
```js
var bus = new Vue()
// 컴포넌트 A의 메소드
bus.$emit('id-selected', 1)
// 컴포넌트 B의 created 훅
bus.$on('id-selected', function (id) {
  // ...
})
```

### 컨텐츠 배포 프로세스
컴포넌트를 사용할 때 다음과 같이 컴포넌트를 구성하는 것이 좋습니다.
```xml
<app>
  <app-header></app-header>
  <app-footer></app-footer>
</app>
```
주목해야할 두가지 사항이 있습니다.
1. `<app>` 컴포넌트는 어떤 컨텐츠를 받을 지 모릅니다. 그것은 `<app>`이 사용하는 컴포넌트에 의해 결정됩니다.
2. `<app>` 컴포넌트에는 자체 템플릿이 있을 가능성이 큽니다.

위 구성으로 작동하도록 하려면 부모 콘텐츠와 컴포넌트의 자체의 템플릿을 섞는 방법이 필요합니다. 이것은 `콘텐츠 배포 프로세스`입니다.
VueJS는 현재 [웹 컴포넌트 사양 초안](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)을
모델로 한 콘텐츠 배포 API를 구현하며 원본 콘텐츠의 배포판 역할 하기 위해 특수한 `<slot>` 엘리먼트를 사용합니다.

#### 범위 컴파일
컴파일되는 범위를 명확히 해야 합니다. 다음과 같은 템플릿이 있다고 상상해보겠습니다.
```xml
<child-component>{{message}}</child-component>
```
`message`가 부모 데이터 또는 자식 데이터 중 부모에 바인딩되어야 합니다. 컴포넌트 범위에 대한 간단한 법칙은 다음과 같습니다.
1. 상위 템플릿의 모든 내용은 상위 범위로 컴파일됩니다.
2. 하위 템플릿의 모든 내용은 하위 범위에서 컴파일됩니다.

일반적인 실수는 부모 템플릿의 하위 속성/메소드에 디렉티브를 바인딩하려고하는 것입니다.
```xml
<child-component v-show="someChildProperty"></child-component>
```
`someChildProperty`가 자식 컴포넌트의 속성이라고 가정하면, 위의 예제는 작동하지 않을 것입니다.