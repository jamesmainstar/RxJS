### 문법의 역사
#### if, while을 만든 이유
사람이 편하게 쓰고 읽을 수 있는 프로그램을 만들기 위해 if, while과 같은 `구조화 프로그래밍`을 만들었다.

#### if else
if의 조건식에 반대가 되는 조건식을 만들기 위해서는 뒤집어서 표현해야 됨으로 혼란 스러울 수 있기 때문에 if else를 만들었다.

#### while
- 반복되는 if를 읽기 쉽게 표현한것
- 조건을 만족하고 있는 동안 블록 안의 내용을 반복하여 실행

#### for
- 수치를 증가시키는 while을 읽기 쉽게 표현
- 한곳에 '시작값, 종료값, 증가값' 3가지를 모두 정리가 되기 때문에 루프의 의도를 쉽게 이해할 수 있다.
- 반면에 while은 '시작값, 종료값, 증가값' 3가지가 분산되어 의도 파악이 힘들다.

#### foreach
- 처리 대상으로 반복제어
- 어떤 대상의 요소 전부에 어떤 처리를 한다.

#### 함수
- 코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능
- 원래 위치로 돌아갈 위치를 저장해 함수 호출 후 돌아간다.
  - 이로 인해 Stack 이 등장한다.
- EDSAC에도 사용되었던 개념이다.

#### 네이밍(변수명, 함수명 등)
메모리 주소를 지정하는 것보다. `알기 쉬운 이름`을 붙여 편리하게 사용하기 위해 만들었다.

#### 스코프
- 이름의 유효 범위
- 전역 스코프만 있었던 시절에 명이 겹치는 이슈가 있어 만들어짐

#### 형
어떤 종류의 값으로 해석 할지를 판단하기 위해 비트열에 `어떤 종류의 값 인가`라는 `추가 데이터`를 붙인것

#### 클래스
- 사용자가 정의하는 형
- 데이터와 데이터 처리를 정의하여 사양을 정의한다.
- 외부와 작업하는 곳은 공개하고, 상세 구현 방법은 숨긴다.

***

### 에러처리
사고 발생 시 큰 사고로 이어지지 않도록 예방하는 것이 필요하여 `실패를 알리는 구조`가 필요했다.

#### 실패를 전달하는 방법
1. 반환값으로 실패를 전달하면 호출처가 반환값을 체크해서 에러 처리를 하는 방법
   - 실패를 놓친다
     - 프로그래머가 반환값 확인을 잊어버렸을 때 실패를 놓치게 된다.
     - 연쇄적으로 문제가 발생할 수 있다.
   - 에러 처리 때문에 코드를 해석하기 어렵다.
     - 원래 하고 싶은 것을 기술한 코드 사이에 실패했을 경우의 코드가 채워져 흐름을 읽기 어렵다.
2. 함수를 호출하기 전에 에러 처리 코드를 등록해두고, 실패 시 에러 처리 코드로 점프하는 방법

***

### 병행처리
한 CPU에서 여러 개를 동시에 처리하는 방법은 사람이 눈치 챌 수 없는 만큼의 시간만큼의 짧은 시간에 복수의 처리를 변경해가며 실행

#### 방법
1. 협력적 멀티 테스크
   - 타이밍이 좋은 시점에 교대
   - 자발적인 처리 교대하는 방법
2. 선점적 멀티 테스크
   - 일정 시간에 교대
   - 강제적으로 중단 시켜 다른 프로그램 시작

#### 경합 상태(Race Condition)
이 상태를 `Thread safe가 아니다` 라고도 하며 발생경우는 아래와 같다.

1. 2가지 처리가 변수를 공유하고 있다.
2. 적어도 하나의 처리가 그 변수를 변경한다.
3. 한쪽 처리가 한 단락 마무리 되기 전에, 다른 한쪽의 처리가 끼어들 가능성있다.

> 1번 해결방안

#### 프로세스
- UNIX에서는 실행중인 프로그램을 이야기한다.
- 프로그램같의 메모리를 공유하지 않는다.
- 메모리 영역을 지정해서 사용한다.

#### 스레드
- 메모리를 공유하는 경량 프로세스
- UNIX 출시 10년 후 메모리를 공유하는 기능이 필요하여 만듬

#### 액터
- 메모리를 공유하지 않는 다.
- 메세지를 보내 데이터를 공유한다.

> 2번 해결방안
#### Immutable, const
- 메모리를 공유해도 변경을 하지 않으면 문제가 없다.
- getter는 있으나, setter가 없다.

> 3번 해결방안
#### 코루틴
- 끼어들지 않게 협력적 스레드를 만든다.

#### 락
- `지금 끼어들면 곤란해` 라는 표식으로 `사용중`이라는 표식이다.
- [문제점] 2개의 명령이 a,b의 unlock과 lock을 교차 요청하면 무한이 상대방 락이 풀리는 것을 기대하는 `Deadlock(교착상태)`가 발생한다.
  - [해결방안] 트렌젝션 메모리 접근법을 착용한다.
  - 트렌젝션 메모리는 실험적으로 해보고, 실패하면 처음부터 다시 고쳐서하고 성공하면 변경을 공유하는 기법이다.

***

### 객체지향
- Alan Kay(객체 지향 발명가, Smallback 설계자)
  - 형/상속은 고생하고 좋지 않다.
  - 객체지향은 `상태를 가진 객체가 메세지를 주고 받아서 커뮤니케이션 하는 것이다.`라고 설명한다.
- Bjarne Stroustrup(C++ 설계자)
  - 객체지향은 사용자 정의형과 상속을 사용한 프로그래밍이다.
  - Class는 사용자 정의형을 만들기 위한 도구이다.
  - Simula의 상속 구조가 문제 해결의 키이다.
- 사물은 객체(Object), 모형은 모델(Model)이라 칭한다.

#### 모형을 만드는 방법
1. Class 사용(C++, java)
   - 현실 세계 사물을 Class로 분류
   - 세분화된 종류는 subclass로 정의
2. Module 또는 Package
   - 함수를 하나로 모아두기 위한 기능
3. Hash에 함수/변수를 정의
   - first-class citizen 을 사용
     - 변수나 데이터 구조안에 담을 수 있다.
     - 파라미터로 전달 할 수 있다.
     - 반환값(return value)으로 사용할 수 있다.
     - 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
     - 동적으로 프로퍼티 할당이 가능하다.
   - javascript로 예를 들면 `{ fn: () => {}, data: 1 }` 이러한 형태이다.
4. Closure
   - 함수 실행시의 이름 공간의 변수를 하나로 묶기 위해 사용하는 방법
   - 함수형 프로그래밍에서 사용하는 방법
   - Closure 라고 불리는 이유?
     - [1987 Ake Wikstrom] 자유 변수를 포함한 식을 '열린 식'이라고 부르고, 그 자유 변수의 바인딩을 조합함으로서 해당식을 닫고 있기 때문이다.