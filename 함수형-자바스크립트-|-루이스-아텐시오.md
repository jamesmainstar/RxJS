#### 서론
코드가 복잡해지지 않게 하려면 어떻게 해야 할까요? 복잡성을 다스리는 비결은, 코드베이스의 크기가 커질수록 복잡성이 증가하지 않도록 붙잡아 두는 것입니다. 바로 여기서 `함수형 프로그래밍`이 요긴하게 쓰이지요.

### 자료구조는 적게, 일은 더 많이
#### 어플리케이션의 제어 흐름
프로그램이 정답에 이르기까지 거치는 경로를 `제어흐름`이라고 합니다.

`명령형 프로그램`은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다.
보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찬다.
```js
let loop = optC()
while (loop) {
  const condition = optA()
  if (condition) {
    optB1()
  } else {
    optB2()
  }
  loop = optC()
}
optD()
```

반면, 선언적 프로그래밍, 특히 함수형 프로그래밍은 독립적인 블랙박스 연산들이 단순하게,
즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습니다. 실제로 함수형 프로그램은 `데이터`와 `제어 흐름` 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다.

덕분에 다음과 같이 코드가 짧아집니다.
```js
optA().optB().optC().optD()
```

#### 메서드 체이닝
`메서드 체이닝`은 여러 메서드를 단일 구문으로 호출하는 `OOP 패턴`입니다. 메서드가 모두 동일한 객체에 속해 있으며 `메서드 흘리기`라고도 합니다.
```js
// OOP
'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun'

// FP
concat(toLowerCase(substring('Functional Programming', 1, 10))), ' is fun')
```
이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다.
로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요.

#### 함수 체이닝
