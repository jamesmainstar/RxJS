#### 서론
코드가 복잡해지지 않게 하려면 어떻게 해야 할까요? 복잡성을 다스리는 비결은, 코드베이스의 크기가 커질수록 복잡성이 증가하지 않도록 붙잡아 두는 것입니다. 바로 여기서 `함수형 프로그래밍`이 요긴하게 쓰이지요.

### 자료구조는 적게, 일은 더 많이
#### 어플리케이션의 제어 흐름
프로그램이 정답에 이르기까지 거치는 경로를 `제어흐름`이라고 합니다.

`명령형 프로그램`은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다.
보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찬다.
```js
let loop = optC()
while (loop) {
  const condition = optA()
  if (condition) {
    optB1()
  } else {
    optB2()
  }
  loop = optC()
}
optD()
```

반면, 선언적 프로그래밍, 특히 함수형 프로그래밍은 독립적인 블랙박스 연산들이 단순하게,
즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습니다. 실제로 함수형 프로그램은 `데이터`와 `제어 흐름` 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다.

덕분에 다음과 같이 코드가 짧아집니다.
```js
optA().optB().optC().optD()
```

#### 메서드 체이닝
`메서드 체이닝`은 여러 메서드를 단일 구문으로 호출하는 `OOP 패턴`입니다. 메서드가 모두 동일한 객체에 속해 있으며 `메서드 흘리기`라고도 합니다.
```js
// OOP
'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun'

// FP
concat(toLowerCase(substring('Functional Programming', 1, 10))), ' is fun')
```
이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다.
로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요.

#### 함수 체이닝
`객체지향 프로그램`은 주로 상속을 통해 코드를 재사용합니다. `순수 객체지향 언어`에서, 특히 언어 자체의 `자료구조`를 구현한 코드를 보면 이런 패턴이 자주 눈에 띕니다. 가령 자바에는 List 인터페이스를 용도에 맞게 달리 구현한 ArrayList, LinkedList, DoublyLinkedList, CopyOnWriteArrayList 등이 있습니다. 이들은 모두 한 부도에서 출발하여 나름대로 특수한 기능을 덧붙인 클래스입니다.

`함수형 프로그래밍`은 접근 방법이 다릅니다. `자료구조`를 새로 만들어 어떤 요건을 충족시키는 게 아니라, `배열` 등의 흔한 자료구조를 이용해
다수의 굵게 나뉜 `고계 연산`을 적용합니다. 이러한 고계 연산으로 다음과 같은 일을 합니다.
- 작업을 수행하기 위해 무슨 일을 해야 하는지 기술된 함수를 인수로 받습니다.
- 임시 변수의 값을 계속 바꾸면서 부수효과를 일으키는 기존 수동 루프를 대체합니다. 그 결과 관리할 코드가 줄고 에러가 날 만한 코드 역시 줄어듭니다.
