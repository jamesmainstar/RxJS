#### 지연 평가 + Promise - L.map, map, take
take, L.map 함수에서 Promise 일 때 동작하도록 수정하면 비동기 데이터와 동기 데이터를 같이 사용할 수 있다.
```js
const take = curry((l, iter) => {
  if (l === 0) return [];
  let res = [];
  iter = L.values(iter);
  return function recur() {
    let cur;
    while (!(cur = iter.next()).done) {
      const a = cur.value;
      if (a instanceof Promise) {
        return a
          .then(a => (res.push(a), res).length == l ? res : recur())
          .catch(e => e == nop ? recur() : Promise.reject(e));
      }
      res.push(a);
      if (res.length == l) return res;
    }
    return res;
  } ();
});
```
```js
L.map = curry(function *(f, coll) {
  for (const a of L.values(coll)) yield go1(a, f);
});
```

#### Kleisli Composition - L.filter, filter, nop, take
filter에 비동기도 전달되는 값의 평가가 거짓일 경우 Promise.reject를 사용합니다. Promise.reject에 인자는 Symbol('nop')이라는 값을 전달합니다. 해당 값을 take에서 처리하게 되면 filter 이후 함수들을 평가가 되지 않습니다.
```js
go([1, 2, 3],
  L.map(v => Promise.resolve(v * v)),
  L.filter(v => v % 2),
  take(2),
  console.log);
```
