### 글의 목적
최근에 객체지향 프로그래밍에 대한 도서를 읽었다.
도서에서는 객체란 무엇인지 본론적인 이야기부터 혼동하기 쉬운 절차형에 대한 설명이 있었다.
이해가 쉬운 흐름으로 정리된 것을 알 수 있었다. 그래서 함수형 프로그래밍도 이러한 형태로 정리할 필요가 있다는 것을 인지하고 정리하게 되었다.

### 목차
- [함수란](#함수란)
- [함수와 프로시저](함수와-프로시저)
- [함수형의 본질](#함수형의-본질)
- [일급함수로 만든 도구들](#일급함수로-만든-도구들)
- [절차지향 객체지향 함수형 코드비교](#절차지향-객체지향-함수형-코드비교)

### 함수란
함수란 하나의 행동이다. 절차의 묶은 행동일수도 있고 대신 값을 전달하는 행동일 수 있고, 대신 함수를 평가하는 행동일 수 있다. 함수는 행동을 의미하는 이름, 외부에서 값을 주입할 수 있는 인자, 외부로 값을 전달할 수 있는 반환으로 이뤄진다. 함수는 외부의 상태를 접근하지 않는 코드로 구현되며 항상 반환은 존재한다.

#### 인자와 반환
모든 인자는 반환에 대응되어야 한다. 인자는 두개 이상의 반환으로 대응될 수 없다. 동일한 인자가 평가될 때 마다 다른 반환을 가지는 것은 외부의 상태를 의존하는 것이다. 즉, 해당 함수는 함수라고 할 수 없다.

두 함수가 존재할 때 한 함수의 반환과 다른 함수의 인자가 동일한 타입일 때 두 함수는 합성을 할 수 있다. 

### 함수와 프로시저
프로시저는 정해진 절차에 따라 내부의 상태를 변경하는 루틴을 의미한다. 내부의 상태를 변경하는 루틴임으로 자율적으로 존재할 수 없으며 객체에 존재한다. 그리고 반환을 하지 않는다. 계산의 결과를 통해 직접 내부의 상태를 변경하기 때문에 반환을 하지 않는다. 그래서 명령(Command)라는 다른 이름도 가진다.

반면에 함수는 상태를 직접 변경하지 않는다. 별도의 상태에 의존하지 않기 때문에 자율적으로 존재할 수 있다. 그리고 항상 반환한다. 계산의 결과를 직접 변경하지 않으므로 외부로 반환한다. 그래서 쿼리(Query)라는 다른 이름도 가진다.

#### 순수함수와 비순수함수
함수를 순수함수라고 불리기도 한다. 순수함수는 평가시점이 변경 되더라도 동일한 결과를 반환한다. 항상 동일한 결과를 반환하기 때문에 다루기 쉬운 함수가 된다. 프로시저는 비순수함수에 속한다. 외부변수를 사용하거나 외부변수를 변경한다. 그래서 평가시점에 따라 다른 효과를 가지기 때문에 평가시점에 미세하게 다뤄야 한다.

```js
// 순수함수
const add = (a, b) => a + b;
const add1 = (obj, b) => ({val : obj.val + b})

// 비순수함수
const add2 = (a, b) => a + b + c;
const add3 = (a, b) => {
  c = b;
  return a + b;
};
const add4 = (obj, b) => {
  obj.val += b;
};
```

### 함수형의 본질
함수형이란 시스템을 함수처럼 여기도록 만들고, 함수를 이용해 시스템을 구성하는 방법이다. 인자와 반환을 통해서 함수들을 조합하여 고차원의 행동을 구성한다. 자료구조를 새로 만들지 않고 프로그래밍 언어의 기본 자료구조를 이용해 고차연산을 적용한다.

#### 일급함수
함수를 일급 요소로 취급하는 것이 함수형의 기본이다.
일급 함수의 특징은 변수 또는 배열, 객체에 담을 수 있다. 그리고 인자로 받을 수 있고, 반환할 수 있다. 이와 같은 특징을 통해 고차함수를 구현할 수 있다.

#### 컨테이너화
잠재적으로 위험한 코드 주위에 안전망(컨테이너)를 설치하는 것이다. 값을 컨테이너화 하는 행위는 함수형 프로그램의 기본 디자인 패턴이다. 값을 안정적으로 다루도 불편성을 지키기 위해 직접 접근을 차단하는 것이다. 이렇게 감싼 값에 접근하는 유일한 방법은 연산을 컨테이너에 매핑하는 것이다.

```js
// Not Cool
f(g(1)); // 4
f(g()); // NaN

// Cool
[1].map(g).map(f); // [4]
[].map(g).map(f); // []
```

#### 상태변화
실용적인 함수형 프로그래밍은 어떤 시스템에서 상태 변화를 완전히 제거하는 것이 아니라 변이가 발생하는 지역을 가능한 최소화하는 것을 목표로 한다.

함수형 프로그래밍에서는 관찰할 수 있는 **상태 변화**를 최소화하려고 애쓴다. 따라서 함수형 원칙을 고수하는 시스템에 새로운 기능을 추가할 때는 새로운 함수가 지역화되고 비파괴적인 데이터 전이 과정에서 어떻게 동작할 것인지를 파악하는 것이 핵심이다.

### 일급함수로 만든 도구들
#### 클로저
**클로저**는 나중에 사용할 목적으로 정의된 스코프에 포함된 외부 바인딩을 캡쳐하는 함수다. 클로저가 캡쳐한 변수를 자유 변수라고 부른다. **바인딩**은 자바스크립트의 이름에 값을 할당하는 행위를 가르킨다. 변수 할당, 함수 인자 사용, this 전달, 프로퍼티 할당 등의 과정에 해당한다.

클로저는 비공개 접근을 제공할 뿐만 아니라 추상화 기법도 제공한다. 예를 들어 클로저를 이용해서 생성 시에 캡쳐되는 어떤 **설정**에 따라 다른 함수를 만들 수 있다.

```js
const plucker = field => obj => (obj && obj[field])
```

```js
const best = { title: '인피니티워', author: 'Peter' }
const books = [{title: '스파이더맨'}, {title: '아이언맨'}, {title: '토르'}]

const extractTitle = plucker('title')
const extractThird = plucker(2)

extractTitle(best) // '인피니티워'
extractThird(books) // {title: '토르'}
```
#### 커링
각각의 논리적 인자에 대응하는 새로운 함수를 반환하는 함수를 **커리함수**라고 한다.

자바스크립트는 인자의 개수와 부가적인 특화 인자의 개수가 정해져 있을 때가 많다. 커링이 발생하는 과정을 명시적으로 보여주고 한개의 인자만 받도록 강제할 수 있다.


```js
const curry = (fn) => (arg) => fn(arg)

parseInt('11') // => 11
parseInt('11', 2) // => 3

['11', '11', '11'].map(parseInt)
// => [11, NaN, 3]

['11', '11', '11'].map(curry(parseInt))
// => [11, 11, 11]
```

#### 부분 적용
**부분적용**은 부분적으로 실행을 마친 다음에 나머지 인자와 함께 즉시 실행한 상태가 되는 함수다.

```js
const partial = (fn, ...arg1) => (...arg2) => fn(...arg1, ...arg2)

const add = (a, b) => a + b
const add10 = partial(add, 10)

add10(5) // 15
```