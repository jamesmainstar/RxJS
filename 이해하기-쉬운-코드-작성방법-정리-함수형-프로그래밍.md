### 함수형 프로그래밍
코드를 완전히 이해했다는 것의 조건 중 **코드를 사이드 이펙트 없이 자유롭게 수정할 수 있다**가 있다는 것을 위에서 설명했다.
이러한 방법은 **함수형 프로그래밍 기법**을 사용하면 대부분 해결 가능하다는 것을 알았다.

프로젝트를 운영하면서 기능이 추가되면 코드가 복잡해지지 않게 해야 한다. **복잡성**을 다스리는 비결은 코드베이스의 크기가 커질수록 복잡성이 증가하지 않도록 붙잡아 두는 것이다. 바로 여기서 **함수형 프로그래밍**이 요긴하게 쓰인다.

#### 함수형 프로그래밍이란?
함수형 프로그래밍은 추상화 단위를 함수로 한다. 함수들을 조립해서 고수준의 동작을 구현한다. 자료구조를 새로 만들어 어떤 요건을 충족시키는 게 아니라, **배열/객체/문자열 등의 흔한 자료구조**를 이용해 문제를 해결한다.

함수형 프로그래밍에서 함수는 **수학적 함수**를 의미한다. 수학적 함수는 입력과 출력이 모두 존재해야하고, 입력에 따른 출력은 항상 동일하게 대응되어야 한다.

함수형 프로그래밍에서는 관찰할 수 있는 **상태 변화**를 최소화하려고 애쓴다. 따라서 함수형 원칙을 고수하는 시스템에 새로운 기능을 추가할 때는 새로운 함수가 지역화되고 비파괴적인 데이터 전이 과정에서 어떻게 동작할 것인지를 파악하는 것이 핵심이다.

실용적인 함수형 프로그래밍은 어떤 시스템에서 상태 변화를 완전히 제거하는 것이 아니라 변이가 발생하는 지역을 가능한 최소화하는 것을 목표로 한다.

```js
const sum = (a, b) => a + b // 수학적 함수 O
const rand = a => Math.random(a) // 수학적 함수 X
```

#### 수학적함수를 좀더 알아봅시다.
함수형 프로그래밍에서 다루는 수학적함수를 **순수함수**라고 부른다. 순수함수는 동일한 인자에 상응하는 **동일한 리턴값**을 가지는 함수이다. 그러므로, 평가시점이 변경이 되더라도 동일한 결과를 리턴하기 때문에 다루기 쉬운함수가 된다. 순수함수는 객체의 변경이 필요할 경우 새로운 객체를 생성하여 리턴한다.

외부변수를 사용하거나 외부변수를 변경하면 순수함수가 아니다. 비순수함수는 평가시점에 따라 다른 결과값을 가지기 때문에 평가시점을 미세하게 다뤄야 한다.

```js
// 순수함수
const add = (a, b) => a + b;
const add1 = (obj, b) => ({val : obj.val + b})

// 비순수함수
const add2 = (a, b) => a + b + c;
const add3 = (a, b) => {
  c = b;
  return a + b;
};
const add4 = (obj, b) => {
  obj.val += b;
};
```

#### 모든 것을 함수로 생각한다.
**함수형 프로그래밍**은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고,
이러한 함수 개념을 가장 우선순위에 놓는다. 함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것.

```js
// 함수를 가장 우선순위에 놓는 것
moveLeft(dog);
moveRight(duck);
moveLeft({ x: 5, y: 2});
moveRight(dog);

// 데이터(객체)를 우선순위에 놓는 것
duck.moveLeft();
duck.moveRight();
dog.moveLeft();
dog.moveRight();
```

#### 응용형 함수를 통해 다형성 만들기
응용형 함수는 인자로 받은 함수가 알고 있는 인자를 해당 함수에게 평가받아 로직을 완성해나가는 것을 말한다. map, filter 와 같은 함수가 응용형 함수라고 한다. 어떠한 데이터 형태인지 관심이 분리가 되고 다형성을 사용할 수 있기 때문에 재사용성이 높아진다.


```js
const filter = (iterable, predicate) => {
  return Array.from(iterable).filter(predicate);
};
const map = (iterable, mapper) => {
  return Array.from(iterable).map(mapper);
}

filter('123', (str) => Number(str) > 1); // ['2', '3']
filter([1,2,3], (str) => Number(str) > 1); // [2, 3]
filter(new Set([1, 2, 3]), (str) => Number(str) > 1); // [2, 3]
```

#### 값 대신 함수를 사용하라
우선 가장 간단한 함수인 repeat부터 살펴보자. repeat는 횟수와 값을 받아서 중복된 값을 횟수만큼 갖는 배열을 만드는 함수이다.
```js
const repeat = (times, value) => {
  return _.map(_.range(times), () => value)
}
```
독립적으로 동작하는 repeat를 구현하는 것도 괜찮지만 `반복성`이라는 일반성을 가지도록 repeat를 구현할 수 있다면
더 좋을 것이다. 즉, 어떤 숫자만큼 값을 반복하는 것도 괜찮지만 어떤 동작을 특정 횟수만큼 반복한다면 더 좋다.
```js
const repeatedly = (times, fun) => _.map(_.range(times), fun)

repeatedly(3, () => Math.floor(Math.random() * 10) + 1)
```
repeatedly 함수는 함수형 스타일로 생각하면 어떤 효과를 거둘 수 있는지 잘 보여 준다.
값 대신 함수를 사용함으로써 `반복성`이라는 새로운 가능성이 열렸다.

#### 명령형과 함수형 비교하기
**명령형 프로그램**은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찬다.

반면, 선언적 프로그래밍, 특히 함수형 프로그래밍은 독립적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높다. 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급한다.

##### 1. 30세 이상인 users를 거른다.
```js
// 명령형
const temp_users = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].age >= 30) {
    temp_users.push(users[i]);
  }
}
// 함수형
const over_30 = users.filter(({age}) => age >= 30);
```
##### 2. 30세 이상인 users의 names를 수집한다.
```js
// 명령형
const names = [];
for (let i = 0; i < temp_users.length; i++) {
  names.push(temp_users[i].name);
}
// 함수형
const names = over_30.map(({name}) => name);
```
##### 3. 30세 미만인 users를 거른다.
```js
// 명령형
const temp_users2 = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].age < 30) {
    temp_users2.push(users[i]);
  }
}
// 함수형
const under_30 = users.filter(({age}) => age < 30);
```
##### 4. 30세 미만인 users의 ages를 수집한다.
```js
// 명령형
const ages = [];
for (let i = 0; i < temp_users2.length; i++) {
  ages.push(temp_users2[i].age);
}
// 함수형
const ages = under_30.map(({age}) => age)
```

#### 추상화 도구 클로저
> **바인딩**은 자바스크립트의 이름에 값을 할당하는 행위를 가르킨다. 변수 할당, 함수 인자 사용, this 전달, 프로퍼티 할당 등의 과정에 해당한다.
**클로저**는 나중에 사용할 목적으로 정의된 스코프에 포함된 외부 바인딩을 캡쳐하는 함수다. 클로저는 비공개 접근을 제공할 뿐만 아니라 추상화 기법도 제공한다. 예를 들어 클로저를 이용해서 생성 시에 캡쳐되는 어떤 **설정**에 따라 다른 함수를 만들 수 있다.

```js
const plucker = field => obj => (obj && obj[field])
```

```js
const best = { title: '인피니티워', author: 'Peter' }
const books = [{title: '스파이더맨'}, {title: '아이언맨'}, {title: '토르'}]

const extractTitle = plucker('title')
const extractThird = plucker(2)

extractTitle(best) // '인피니티워'
extractThird(books) // {title: '토르'}
```