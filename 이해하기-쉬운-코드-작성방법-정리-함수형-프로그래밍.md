### 함수형 프로그래밍
코드를 완전히 이해했다는 것의 조건 중 **코드를 사이드 이펙트 없이 자유롭게 수정할 수 있다**가 있다는 것을 위에서 설명했다.
이러한 방법은 **함수형 프로그래밍 기법**을 사용하면 대부분 해결 가능하다는 것을 알았다.

프로젝트를 운영하면서 기능이 추가되면 코드가 복잡해지지 않게 해야 한다. **복잡성**을 다스리는 비결은 코드베이스의 크기가 커질수록 복잡성이 증가하지 않도록 붙잡아 두는 것이다. 바로 여기서 **함수형 프로그래밍**이 요긴하게 쓰인다.

#### 함수형 프로그래밍이란?
함수형 프로그래밍은 추상화 단위를 함수로 한다. 함수들을 조립해서 고수준의 동작을 구현한다. 자료구조를 새로 만들어 어떤 요건을 충족시키는 게 아니라, 배열/객체/문자열 등의 흔한 자료구조를 이용해 문제를 해결한다.

함수형 프로그래밍에서 함수는 **수학적 함수**를 의미한다. 수학적 함수는 입력과 출력이 모두 존재해야하고, 입력에 따른 출력은 항상 동일하게 대응되어야 한다.

```js
const sum = (a, b) => a + b // 수학적 함수 O
const rand = a => Math.random(a) // 수학적 함수 X
```

#### 순수함수
함수형 프로그래밍에서 다루는 수학적함수를 **순수함수**라고 부른다. 순수함수는 동일한 인자에 상응하는 **동일한 리턴값**을 가지는 함수입니다. 그러므로, 평가시점이 변경이 되더라도 동일한 결과를 리턴하기 때문에 다루기 쉬운함수가 됩니다. 순수함수는 객체의 변경이 필요할 경우 새로운 객체를 생성하여 리턴합니다.

외부변수를 사용하거나 외부변수를 변경하면 순수함수가 아닙니다. 비순수함수는 평가시점에 따라 다른 결과값을 가지기 때문에 평가시점을 미세하게 다뤄야 합니다.

```js
// 순수함수
const add = (a, b) => a + b;
const add1 = (obj, b) => ({val : obj.val + b})

// 비순수함수
const add2 = (a, b) => a + b + c;
const add3 = (a, b) => {
  c = b;
  return a + b;
};
const add4 = (obj, b) => {
  obj.val += b;
};
```

#### 모든 것을 함수로 생각한다.
**함수형 프로그래밍**은 애플리케이션, 함수의 구성요소, 더 나아가서 언어 자체를 함수처럼 여기도록 만들고,
이러한 함수 개념을 가장 우선순위에 놓는다. 함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것.

```js
// 함수를 가장 우선순위에 놓는 것
moveLeft(dog);
moveRight(duck);
moveLeft({ x: 5, y: 2});
moveRight(dog);

// 데이터(객체)를 우선순위에 놓는 것
duck.moveLeft();
duck.moveRight();
dog.moveLeft();
dog.moveRight();
```

#### 명령형에서 함수형으로 전환하기
**명령형 프로그램**은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찬다.

반면, 선언적 프로그래밍, 특히 함수형 프로그래밍은 독립적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습니다. 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다.

##### 1. 30세 이상인 users를 거른다.
```js
// 명령형
const temp_users = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].age >= 30) {
    temp_users.push(users[i]);
  }
}
// 함수형
const over_30 = users.filter(({age}) => age >= 30);
```
##### 2. 30세 이상인 users의 names를 수집한다.
```js
// 명령형
const names = [];
for (let i = 0; i < temp_users.length; i++) {
  names.push(temp_users[i].name);
}
// 함수형
const names = over_30.map(({name}) => name);
```
##### 3. 30세 미만인 users를 거른다.
```js
// 명령형
const temp_users2 = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].age < 30) {
    temp_users2.push(users[i]);
  }
}
// 함수형
const under_30 = users.filter(({age}) => age < 30);
```
##### 4. 30세 미만인 users의 ages를 수집한다.
```js
// 명령형
const ages = [];
for (let i = 0; i < temp_users2.length; i++) {
  ages.push(temp_users2[i].age);
}
// 함수형
const ages = under_30.map(({age}) => age)
```